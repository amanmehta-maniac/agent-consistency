{"model_name_or_path": "llama", "instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e2729..5bcaac6da 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -303,7 +303,13 @@ def _separable(transform):\n     \"\"\"\n     if (transform_matrix := transform._calculate_separability_matrix()) is not NotImplemented:\n         return transform_matrix\n-    elif isinstance(transform, CompoundModel):\n+    if isinstance(transform.right, CompoundModel):\n+        sepright = _separable(transform.right)\n+    else:\n+        sepright = _coord_matrix(transform.right, 'right', transform.right.n_outputs)\n+    return _operators[transform.op](sepleft, sepright)\n+    if isinstance(transform.left, CompoundModel) or isinstance(transform.right, CompoundModel):\n+        raise NotImplementedError(\"Nested compound models are not supported\")\n         sepleft = _separable(transform.left)\n         sepright = _separable(transform.right)\n         return _operators[transform.op](sepleft, sepright)\n@@ -315,3 +321,15 @@ def _separable(transform):\n # relationship of axes as an array of 0-es and 1-s\n _operators = {'&': _cstack, '|': _cdot, '+': _arith_oper, '-': _arith_oper,\n               '*': _arith_oper, '/': _arith_oper, '**': _arith_oper}\n+    if isinstance(transform, CompoundModel):\n+        if isinstance(transform.left, CompoundModel):\n+            sepleft = _separable(transform.left)\n+        else:\n+            sepleft = _coord_matrix(transform.left, 'left', transform.left.n_outputs)\n+        if isinstance(transform.right, CompoundModel):\n+            sepright = _separable(transform.right)\n+        else:\n+            sepright = _coord_matrix(transform.right, 'right', transform.right.n_outputs)\n+        return _operators[transform.op](sepleft, sepright)\n+    elif isinstance(transform, Model):\n+        return _coord_matrix(transform, 'left', transform.n_outputs)\ndiff --git a/test_separability.py b/test_separability.py\nnew file mode 100644\nindex 000000000..d5b218417\n--- /dev/null\n+++ b/test_separability.py\n@@ -0,0 +1,5 @@\n+from astropy.modeling import models as m\n+from astropy.modeling.separable import separability_matrix\n+\n+cm = m.Linear1D(10) & m.Linear1D(5)\n+print(separability_matrix(m.Pix2Sky_TAN() & cm))\n"}
{"model_name_or_path": "llama", "instance_id": "astropy__astropy-13033", "model_patch": ""}
{"model_name_or_path": "llama", "instance_id": "astropy__astropy-13236", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127a..c911f09f7 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1242,6 +1242,8 @@ class Table:\n         # Structured ndarray gets viewed as a mixin unless already a valid\n         # mixin class\n         if (not isinstance(data, Column) and not data_is_mixin\n+        if astropy.__version__ >= \"5.2\": data = Column(data)\n+        warnings.warn(\"In the future, structured arrays will be added as Column objects.\", FutureWarning)\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n             data = data.view(NdarrayMixin)\n             data_is_mixin = True\n"}
{"model_name_or_path": "llama", "instance_id": "astropy__astropy-13398", "model_patch": ""}
{"model_name_or_path": "llama", "instance_id": "astropy__astropy-13453", "model_patch": "diff --git a/test_html.py b/test_html.py\nnew file mode 100644\nindex 000000000..9c618a023\n--- /dev/null\n+++ b/test_html.py\n@@ -0,0 +1,11 @@\n+from astropy.table import Table\n+from io import StringIO\n+\n+# generate table\n+t = Table([(1.23875234858e-24, 3.2348748432e-15), (2, 4)], names=('a', 'b'))\n+tc = t.copy()  # copy table\n+\n+# print HTML table with \"a\" column formatted to show 2 decimal places\n+with StringIO() as sp:\n+    tc.write(sp, format=\"html_with_formats\", formats={\"a\": lambda x: f\"{x:.2e}\"})\n+    print(sp.getvalue())\n"}
{"model_name_or_path": "llama", "instance_id": "astropy__astropy-13579", "model_patch": "diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\nindex d7605b078..29e981849 100644\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n@@ -251,7 +251,7 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n-                world_arrays_new.append(1.)\n+                world_arrays_new.append(np.nan)\n \n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n"}
{"model_name_or_path": "llama", "instance_id": "astropy__astropy-13977", "model_patch": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb..043975d12 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -618,1612 +618,5 @@ class Quantity(np.ndarray):\n         )\n \n     def __array_ufunc__(self, function, method, *inputs, **kwargs):\n-        \"\"\"Wrap numpy ufuncs, taking care of units.\n-\n-        Parameters\n-        ----------\n-        function : callable\n-            ufunc to wrap.\n-        method : str\n-            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\n-        inputs : tuple\n-            Input arrays.\n-        kwargs : keyword arguments\n-            As passed on, with ``out`` containing possible quantity output.\n-\n-        Returns\n-        -------\n-        result : `~astropy.units.Quantity`\n-            Results of the ufunc, with the unit set properly.\n-        \"\"\"\n-        # Determine required conversion functions -- to bring the unit of the\n-        # input to that expected (e.g., radian for np.sin), or to get\n-        # consistent units between two inputs (e.g., in np.add) --\n-        # and the unit of the result (or tuple of units for nout > 1).\n-        converters, unit = converters_and_unit(function, method, *inputs)\n-\n-        out = kwargs.get(\"out\", None)\n-        # Avoid loop back by turning any Quantity output into array views.\n-        if out is not None:\n-            # If pre-allocated output is used, check it is suitable.\n-            # This also returns array view, to ensure we don't loop back.\n-            if function.nout == 1:\n-                out = out[0]\n-            out_array = check_output(out, unit, inputs, function=function)\n-            # Ensure output argument remains a tuple.\n-            kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\n-\n-        if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\n-            # Special-case for initial argument for reductions like\n-            # np.add.reduce.  This should be converted to the output unit as\n-            # well, which is typically the same as the input unit (but can\n-            # in principle be different: unitless for np.equal, radian\n-            # for np.arctan2, though those are not necessarily useful!)\n-            kwargs[\"initial\"] = self._to_own_unit(\n-                kwargs[\"initial\"], check_precision=False, unit=unit\n-            )\n-\n-        # Same for inputs, but here also convert if necessary.\n-        arrays = []\n-        for input_, converter in zip(inputs, converters):\n-            input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n-\n-        # Call our superclass's __array_ufunc__\n-        result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n-        # If unit is None, a plain array is expected (e.g., comparisons), which\n-        # means we're done.\n-        # We're also done if the result was None (for method 'at') or\n-        # NotImplemented, which can happen if other inputs/outputs override\n-        # __array_ufunc__; hopefully, they can then deal with us.\n-        if unit is None or result is None or result is NotImplemented:\n-            return result\n-\n-        return self._result_as_quantity(result, unit, out)\n-\n-    def _result_as_quantity(self, result, unit, out):\n-        \"\"\"Turn result into a quantity with the given unit.\n-\n-        If no output is given, it will take a view of the array as a quantity,\n-        and set the unit.  If output is given, those should be quantity views\n-        of the result arrays, and the function will just set the unit.\n-\n-        Parameters\n-        ----------\n-        result : ndarray or tuple thereof\n-            Array(s) which need to be turned into quantity.\n-        unit : `~astropy.units.Unit`\n-            Unit for the quantities to be returned (or `None` if the result\n-            should not be a quantity).  Should be tuple if result is a tuple.\n-        out : `~astropy.units.Quantity` or None\n-            Possible output quantity. Should be `None` or a tuple if result\n-            is a tuple.\n-\n-        Returns\n-        -------\n-        out : `~astropy.units.Quantity`\n-           With units set.\n-        \"\"\"\n-        if isinstance(result, (tuple, list)):\n-            if out is None:\n-                out = (None,) * len(result)\n-            return result.__class__(\n-                self._result_as_quantity(result_, unit_, out_)\n-                for (result_, unit_, out_) in zip(result, unit, out)\n-            )\n-\n-        if out is None:\n-            # View the result array as a Quantity with the proper unit.\n-            return result if unit is None else self._new_view(result, unit)\n-\n-        elif isinstance(out, Quantity):\n-            # For given Quantity output, just set the unit. We know the unit\n-            # is not None and the output is of the correct Quantity subclass,\n-            # as it was passed through check_output.\n-            # (We cannot do this unconditionally, though, since it is possible\n-            # for out to be ndarray and the unit to be dimensionless.)\n-            out._set_unit(unit)\n-\n-        return out\n-\n-    def __quantity_subclass__(self, unit):\n-        \"\"\"\n-        Overridden by subclasses to change what kind of view is\n-        created based on the output unit of an operation.\n-\n-        Parameters\n-        ----------\n-        unit : UnitBase\n-            The unit for which the appropriate class should be returned\n-\n-        Returns\n-        -------\n-        tuple :\n-            - `~astropy.units.Quantity` subclass\n-            - bool: True if subclasses of the given class are ok\n-        \"\"\"\n-        return Quantity, True\n-\n-    def _new_view(self, obj=None, unit=None):\n-        \"\"\"\n-        Create a Quantity view of some array-like input, and set the unit\n-\n-        By default, return a view of ``obj`` of the same class as ``self`` and\n-        with the same unit.  Subclasses can override the type of class for a\n-        given unit using ``__quantity_subclass__``, and can ensure properties\n-        other than the unit are copied using ``__array_finalize__``.\n-\n-        If the given unit defines a ``_quantity_class`` of which ``self``\n-        is not an instance, a view using this class is taken.\n-\n-        Parameters\n-        ----------\n-        obj : ndarray or scalar, optional\n-            The array to create a view of.  If obj is a numpy or python scalar,\n-            it will be converted to an array scalar.  By default, ``self``\n-            is converted.\n-\n-        unit : unit-like, optional\n-            The unit of the resulting object.  It is used to select a\n-            subclass, and explicitly assigned to the view if given.\n-            If not given, the subclass and unit will be that of ``self``.\n-\n-        Returns\n-        -------\n-        view : `~astropy.units.Quantity` subclass\n-        \"\"\"\n-        # Determine the unit and quantity subclass that we need for the view.\n-        if unit is None:\n-            unit = self.unit\n-            quantity_subclass = self.__class__\n-        elif unit is self.unit and self.__class__ is Quantity:\n-            # The second part is because we should not presume what other\n-            # classes want to do for the same unit.  E.g., Constant will\n-            # always want to fall back to Quantity, and relies on going\n-            # through `__quantity_subclass__`.\n-            quantity_subclass = Quantity\n-        else:\n-            unit = Unit(unit)\n-            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\n-            if isinstance(self, quantity_subclass):\n-                quantity_subclass, subok = self.__quantity_subclass__(unit)\n-                if subok:\n-                    quantity_subclass = self.__class__\n-\n-        # We only want to propagate information from ``self`` to our new view,\n-        # so obj should be a regular array.  By using ``np.array``, we also\n-        # convert python and numpy scalars, which cannot be viewed as arrays\n-        # and thus not as Quantity either, to zero-dimensional arrays.\n-        # (These are turned back into scalar in `.value`)\n-        # Note that for an ndarray input, the np.array call takes only double\n-        # ``obj.__class is np.ndarray``. So, not worth special-casing.\n-        if obj is None:\n-            obj = self.view(np.ndarray)\n-        else:\n-            obj = np.array(obj, copy=False, subok=True)\n-\n-        # Take the view, set the unit, and update possible other properties\n-        # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\n-        view = obj.view(quantity_subclass)\n-        view._set_unit(unit)\n-        view.__array_finalize__(self)\n-        return view\n-\n-    def _set_unit(self, unit):\n-        \"\"\"Set the unit.\n-\n-        This is used anywhere the unit is set or modified, i.e., in the\n-        initilizer, in ``__imul__`` and ``__itruediv__`` for in-place\n-        multiplication and division by another unit, as well as in\n-        ``__array_finalize__`` for wrapping up views.  For Quantity, it just\n-        sets the unit, but subclasses can override it to check that, e.g.,\n-        a unit is consistent.\n-        \"\"\"\n-        if not isinstance(unit, UnitBase):\n-            if isinstance(self._unit, StructuredUnit) or isinstance(\n-                unit, StructuredUnit\n-            ):\n-                unit = StructuredUnit(unit, self.dtype)\n-            else:\n-                # Trying to go through a string ensures that, e.g., Magnitudes with\n-                # dimensionless physical unit become Quantity with units of mag.\n-                unit = Unit(str(unit), parse_strict=\"silent\")\n-                if not isinstance(unit, (UnitBase, StructuredUnit)):\n-                    raise UnitTypeError(\n-                        f\"{self.__class__.__name__} instances require normal units, \"\n-                        f\"not {unit.__class__} instances.\"\n-                    )\n-\n-        self._unit = unit\n-\n-    def __deepcopy__(self, memo):\n-        # If we don't define this, ``copy.deepcopy(quantity)`` will\n-        # return a bare Numpy array.\n-        return self.copy()\n-\n-    def __reduce__(self):\n-        # patch to pickle Quantity objects (ndarray subclasses), see\n-        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\n-\n-        object_state = list(super().__reduce__())\n-        object_state[2] = (object_state[2], self.__dict__)\n-        return tuple(object_state)\n-\n-    def __setstate__(self, state):\n-        # patch to unpickle Quantity objects (ndarray subclasses), see\n-        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\n-\n-        nd_state, own_state = state\n-        super().__setstate__(nd_state)\n-        self.__dict__.update(own_state)\n-\n-    info = QuantityInfo()\n-\n-    def _to_value(self, unit, equivalencies=[]):\n-        \"\"\"Helper method for to and to_value.\"\"\"\n-        if equivalencies == []:\n-            equivalencies = self._equivalencies\n-        if not self.dtype.names or isinstance(self.unit, StructuredUnit):\n-            # Standard path, let unit to do work.\n-            return self.unit.to(\n-                unit, self.view(np.ndarray), equivalencies=equivalencies\n-            )\n-\n-        else:\n-            # The .to() method of a simple unit cannot convert a structured\n-            # dtype, so we work around it, by recursing.\n-            # TODO: deprecate this?\n-            # Convert simple to Structured on initialization?\n-            result = np.empty_like(self.view(np.ndarray))\n-            for name in self.dtype.names:\n-                result[name] = self[name]._to_value(unit, equivalencies)\n-            return result\n-\n-    def to(self, unit, equivalencies=[], copy=True):\n-        \"\"\"\n-        Return a new `~astropy.units.Quantity` object with the specified unit.\n-\n-        Parameters\n-        ----------\n-        unit : unit-like\n-            An object that represents the unit to convert to. Must be\n-            an `~astropy.units.UnitBase` object or a string parseable\n-            by the `~astropy.units` package.\n-\n-        equivalencies : list of tuple\n-            A list of equivalence pairs to try if the units are not\n-            directly convertible.  See :ref:`astropy:unit_equivalencies`.\n-            If not provided or ``[]``, class default equivalencies will be used\n-            (none for `~astropy.units.Quantity`, but may be set for subclasses)\n-            If `None`, no equivalencies will be applied at all, not even any\n-            set globally or within a context.\n-\n-        copy : bool, optional\n-            If `True` (default), then the value is copied.  Otherwise, a copy\n-            will only be made if necessary.\n-\n-        See also\n-        --------\n-        to_value : get the numerical value in a given unit.\n-        \"\"\"\n-        # We don't use `to_value` below since we always want to make a copy\n-        # and don't want to slow down this method (esp. the scalar case).\n-        unit = Unit(unit)\n-        if copy:\n-            # Avoid using to_value to ensure that we make a copy. We also\n-            # don't want to slow down this method (esp. the scalar case).\n-            value = self._to_value(unit, equivalencies)\n-        else:\n-            # to_value only copies if necessary\n-            value = self.to_value(unit, equivalencies)\n-        return self._new_view(value, unit)\n-\n-    def to_value(self, unit=None, equivalencies=[]):\n-        \"\"\"\n-        The numerical value, possibly in a different unit.\n-\n-        Parameters\n-        ----------\n-        unit : unit-like, optional\n-            The unit in which the value should be given. If not given or `None`,\n-            use the current unit.\n-\n-        equivalencies : list of tuple, optional\n-            A list of equivalence pairs to try if the units are not directly\n-            convertible (see :ref:`astropy:unit_equivalencies`). If not provided\n-            or ``[]``, class default equivalencies will be used (none for\n-            `~astropy.units.Quantity`, but may be set for subclasses).\n-            If `None`, no equivalencies will be applied at all, not even any\n-            set globally or within a context.\n-\n-        Returns\n-        -------\n-        value : ndarray or scalar\n-            The value in the units specified. For arrays, this will be a view\n-            of the data if no unit conversion was necessary.\n-\n-        See also\n-        --------\n-        to : Get a new instance in a different unit.\n-        \"\"\"\n-        if unit is None or unit is self.unit:\n-            value = self.view(np.ndarray)\n-        elif not self.dtype.names:\n-            # For non-structured, we attempt a short-cut, where we just get\n-            # the scale.  If that is 1, we do not have to do anything.\n-            unit = Unit(unit)\n-            # We want a view if the unit does not change.  One could check\n-            # with \"==\", but that calculates the scale that we need anyway.\n-            # TODO: would be better for `unit.to` to have an in-place flag.\n-            try:\n-                scale = self.unit._to(unit)\n-            except Exception:\n-                # Short-cut failed; try default (maybe equivalencies help).\n-                value = self._to_value(unit, equivalencies)\n-            else:\n-                value = self.view(np.ndarray)\n-                if not is_effectively_unity(scale):\n-                    # not in-place!\n-                    value = value * scale\n-        else:\n-            # For structured arrays, we go the default route.\n-            value = self._to_value(unit, equivalencies)\n-\n-        # Index with empty tuple to decay array scalars in to numpy scalars.\n-        return value if value.shape else value[()]\n-\n-    value = property(\n-        to_value,\n-        doc=\"\"\"The numerical value of this instance.\n-\n-    See also\n-    --------\n-    to_value : Get the numerical value in a given unit.\n-    \"\"\",\n-    )\n-\n-    @property\n-    def unit(self):\n-        \"\"\"\n-        A `~astropy.units.UnitBase` object representing the unit of this\n-        quantity.\n-        \"\"\"\n-\n-        return self._unit\n-\n-    @property\n-    def equivalencies(self):\n-        \"\"\"\n-        A list of equivalencies that will be applied by default during\n-        unit conversions.\n-        \"\"\"\n-\n-        return self._equivalencies\n-\n-    def _recursively_apply(self, func):\n-        \"\"\"Apply function recursively to every field.\n-\n-        Returns a copy with the result.\n-        \"\"\"\n-        result = np.empty_like(self)\n-        result_value = result.view(np.ndarray)\n-        result_unit = ()\n-        for name in self.dtype.names:\n-            part = func(self[name])\n-            result_value[name] = part.value\n-            result_unit += (part.unit,)\n-\n-        result._set_unit(result_unit)\n-        return result\n-\n-    @property\n-    def si(self):\n-        \"\"\"\n-        Returns a copy of the current `Quantity` instance with SI units. The\n-        value of the resulting object will be scaled.\n-        \"\"\"\n-        if self.dtype.names:\n-            return self._recursively_apply(operator.attrgetter(\"si\"))\n-        si_unit = self.unit.si\n-        return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\n-\n-    @property\n-    def cgs(self):\n-        \"\"\"\n-        Returns a copy of the current `Quantity` instance with CGS units. The\n-        value of the resulting object will be scaled.\n-        \"\"\"\n-        if self.dtype.names:\n-            return self._recursively_apply(operator.attrgetter(\"cgs\"))\n-        cgs_unit = self.unit.cgs\n-        return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\n-\n-    @property\n-    def isscalar(self):\n-        \"\"\"\n-        True if the `value` of this quantity is a scalar, or False if it\n-        is an array-like object.\n-\n-        .. note::\n-            This is subtly different from `numpy.isscalar` in that\n-            `numpy.isscalar` returns False for a zero-dimensional array\n-            (e.g. ``np.array(1)``), while this is True for quantities,\n-            since quantities cannot represent true numpy scalars.\n-        \"\"\"\n-        return not self.shape\n-\n-    # This flag controls whether convenience conversion members, such\n-    # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\n-    # not turned on on Quantity itself, but is on some subclasses of\n-    # Quantity, such as `astropy.coordinates.Angle`.\n-    _include_easy_conversion_members = False\n-\n-    def __dir__(self):\n-        \"\"\"\n-        Quantities are able to directly convert to other units that\n-        have the same physical type.  This function is implemented in\n-        order to make autocompletion still work correctly in IPython.\n-        \"\"\"\n-        if not self._include_easy_conversion_members:\n-            return super().__dir__()\n-\n-        dir_values = set(super().__dir__())\n-        equivalencies = Unit._normalize_equivalencies(self.equivalencies)\n-        for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\n-            dir_values.update(equivalent.names)\n-        return sorted(dir_values)\n-\n-    def __getattr__(self, attr):\n-        \"\"\"\n-        Quantities are able to directly convert to other units that\n-        have the same physical type.\n-        \"\"\"\n-        if not self._include_easy_conversion_members:\n-            raise AttributeError(\n-                f\"'{self.__class__.__name__}' object has no '{attr}' member\"\n-            )\n-\n-        def get_virtual_unit_attribute():\n-            registry = get_current_unit_registry().registry\n-            to_unit = registry.get(attr, None)\n-            if to_unit is None:\n-                return None\n-\n-            try:\n-                return self.unit.to(\n-                    to_unit, self.value, equivalencies=self.equivalencies\n-                )\n-            except UnitsError:\n-                return None\n-\n-        value = get_virtual_unit_attribute()\n-\n-        if value is None:\n-            raise AttributeError(\n-                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\n-            )\n-        else:\n-            return value\n-\n-    # Equality needs to be handled explicitly as ndarray.__eq__ gives\n-    # DeprecationWarnings on any error, which is distracting, and does not\n-    # deal well with structured arrays (nor does the ufunc).\n-    def __eq__(self, other):\n-        try:\n-            other_value = self._to_own_unit(other)\n-        except UnitsError:\n-            return False\n-        except Exception:\n-            return NotImplemented\n-        return self.value.__eq__(other_value)\n-\n-    def __ne__(self, other):\n-        try:\n-            other_value = self._to_own_unit(other)\n-        except UnitsError:\n-            return True\n-        except Exception:\n-            return NotImplemented\n-        return self.value.__ne__(other_value)\n-\n-    # Unit conversion operator (<<).\n-    def __lshift__(self, other):\n-        try:\n-            other = Unit(other, parse_strict=\"silent\")\n-        except UnitTypeError:\n-            return NotImplemented\n-\n-        return self.__class__(self, other, copy=False, subok=True)\n-\n-    def __ilshift__(self, other):\n-        try:\n-            other = Unit(other, parse_strict=\"silent\")\n-        except UnitTypeError:\n-            return NotImplemented  # try other.__rlshift__(self)\n-\n-        try:\n-            factor = self.unit._to(other)\n-        except UnitConversionError:  # incompatible, or requires an Equivalency\n-            return NotImplemented\n-        except AttributeError:  # StructuredUnit does not have `_to`\n-            # In principle, in-place might be possible.\n-            return NotImplemented\n-\n-        view = self.view(np.ndarray)\n-        try:\n-            view *= factor  # operates on view\n-        except TypeError:\n-            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\n-            # which inherits from `TypeError`.\n-            return NotImplemented\n-\n-        self._set_unit(other)\n-        return self\n-\n-    def __rlshift__(self, other):\n-        if not self.isscalar:\n-            return NotImplemented\n-        return Unit(self).__rlshift__(other)\n-\n-    # Give warning for other >> self, since probably other << self was meant.\n-    def __rrshift__(self, other):\n-        warnings.warn(\n-            \">> is not implemented. Did you mean to convert \"\n-            \"something to this quantity as a unit using '<<'?\",\n-            AstropyWarning,\n-        )\n-        return NotImplemented\n-\n-    # Also define __rshift__ and __irshift__ so we override default ndarray\n-    # behaviour, but instead of emitting a warning here, let it be done by\n-    # other (which likely is a unit if this was a mistake).\n-    def __rshift__(self, other):\n-        return NotImplemented\n-\n-    def __irshift__(self, other):\n-        return NotImplemented\n-\n-    # Arithmetic operations\n-    def __mul__(self, other):\n-        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\n-\n-        if isinstance(other, (UnitBase, str)):\n-            try:\n-                return self._new_view(self.copy(), other * self.unit)\n-            except UnitsError:  # let other try to deal with it\n-                return NotImplemented\n-\n-        return super().__mul__(other)\n-\n-    def __imul__(self, other):\n-        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\n-\n-        if isinstance(other, (UnitBase, str)):\n-            self._set_unit(other * self.unit)\n-            return self\n-\n-        return super().__imul__(other)\n-\n-    def __rmul__(self, other):\n-        \"\"\"\n-        Right Multiplication between `Quantity` objects and other objects.\n-        \"\"\"\n-\n-        return self.__mul__(other)\n-\n-    def __truediv__(self, other):\n-        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\n-\n-        if isinstance(other, (UnitBase, str)):\n-            try:\n-                return self._new_view(self.copy(), self.unit / other)\n-            except UnitsError:  # let other try to deal with it\n-                return NotImplemented\n-\n-        return super().__truediv__(other)\n-\n-    def __itruediv__(self, other):\n-        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\n-\n-        if isinstance(other, (UnitBase, str)):\n-            self._set_unit(self.unit / other)\n-            return self\n-\n-        return super().__itruediv__(other)\n-\n-    def __rtruediv__(self, other):\n-        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\n-\n-        if isinstance(other, (UnitBase, str)):\n-            return self._new_view(1.0 / self.value, other / self.unit)\n-\n-        return super().__rtruediv__(other)\n-\n-    def __pow__(self, other):\n-        if isinstance(other, Fraction):\n-            # Avoid getting object arrays by raising the value to a Fraction.\n-            return self._new_view(self.value ** float(other), self.unit**other)\n-\n-        return super().__pow__(other)\n-\n-    # other overrides of special functions\n-    def __hash__(self):\n-        return hash(self.value) ^ hash(self.unit)\n-\n-    def __iter__(self):\n-        if self.isscalar:\n-            raise TypeError(\n-                f\"'{self.__class__.__name__}' object with a scalar value is not\"\n-                \" iterable\"\n-            )\n-\n-        # Otherwise return a generator\n-        def quantity_iter():\n-            for val in self.value:\n-                yield self._new_view(val)\n-\n-        return quantity_iter()\n-\n-    def __getitem__(self, key):\n-        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\n-            return self._new_view(self.view(np.ndarray)[key], self.unit[key])\n-\n-        try:\n-            out = super().__getitem__(key)\n-        except IndexError:\n-            # We want zero-dimensional Quantity objects to behave like scalars,\n-            # so they should raise a TypeError rather than an IndexError.\n-            if self.isscalar:\n-                raise TypeError(\n-                    f\"'{self.__class__.__name__}' object with a scalar value \"\n-                    \"does not support indexing\"\n-                )\n-            else:\n-                raise\n-        # For single elements, ndarray.__getitem__ returns scalars; these\n-        # need a new view as a Quantity.\n-        if not isinstance(out, np.ndarray):\n-            out = self._new_view(out)\n-        return out\n-\n-    def __setitem__(self, i, value):\n-        if isinstance(i, str):\n-            # Indexing will cause a different unit, so by doing this in\n-            # two steps we effectively try with the right unit.\n-            self[i][...] = value\n-            return\n-\n-        # update indices in info if the info property has been accessed\n-        # (in which case 'info' in self.__dict__ is True; this is guaranteed\n-        # to be the case if we're part of a table).\n-        if not self.isscalar and \"info\" in self.__dict__:\n-            self.info.adjust_indices(i, value, len(self))\n-        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))\n-\n-    # __contains__ is OK\n-\n-    def __bool__(self):\n-        \"\"\"Quantities should always be treated as non-False; there is too much\n-        potential for ambiguity otherwise.\n-        \"\"\"\n-        warnings.warn(\n-            \"The truth value of a Quantity is ambiguous. \"\n-            \"In the future this will raise a ValueError.\",\n-            AstropyDeprecationWarning,\n-        )\n-        return True\n-\n-    def __len__(self):\n-        if self.isscalar:\n-            raise TypeError(\n-                f\"'{self.__class__.__name__}' object with a scalar value has no len()\"\n-            )\n-        else:\n-            return len(self.value)\n-\n-    # Numerical types\n-    def __float__(self):\n-        try:\n-            return float(self.to_value(dimensionless_unscaled))\n-        except (UnitsError, TypeError):\n-            raise TypeError(\n-                \"only dimensionless scalar quantities can be \"\n-                \"converted to Python scalars\"\n-            )\n-\n-    def __int__(self):\n-        try:\n-            return int(self.to_value(dimensionless_unscaled))\n-        except (UnitsError, TypeError):\n-            raise TypeError(\n-                \"only dimensionless scalar quantities can be \"\n-                \"converted to Python scalars\"\n-            )\n-\n-    def __index__(self):\n-        # for indices, we do not want to mess around with scaling at all,\n-        # so unlike for float, int, we insist here on unscaled dimensionless\n-        try:\n-            assert self.unit.is_unity()\n-            return self.value.__index__()\n-        except Exception:\n-            raise TypeError(\n-                \"only integer dimensionless scalar quantities \"\n-                \"can be converted to a Python index\"\n-            )\n-\n-    # TODO: we may want to add a hook for dimensionless quantities?\n-    @property\n-    def _unitstr(self):\n-        if self.unit is None:\n-            unitstr = _UNIT_NOT_INITIALISED\n-        else:\n-            unitstr = str(self.unit)\n-\n-        if unitstr:\n-            unitstr = \" \" + unitstr\n-\n-        return unitstr\n-\n-    def to_string(self, unit=None, precision=None, format=None, subfmt=None):\n-        \"\"\"\n-        Generate a string representation of the quantity and its unit.\n-\n-        The behavior of this function can be altered via the\n-        `numpy.set_printoptions` function and its various keywords.  The\n-        exception to this is the ``threshold`` keyword, which is controlled via\n-        the ``[units.quantity]`` configuration item ``latex_array_threshold``.\n-        This is treated separately because the numpy default of 1000 is too big\n-        for most browsers to handle.\n-\n-        Parameters\n-        ----------\n-        unit : unit-like, optional\n-            Specifies the unit.  If not provided,\n-            the unit used to initialize the quantity will be used.\n-\n-        precision : number, optional\n-            The level of decimal precision. If `None`, or not provided,\n-            it will be determined from NumPy print options.\n-\n-        format : str, optional\n-            The format of the result. If not provided, an unadorned\n-            string is returned. Supported values are:\n-\n-            - 'latex': Return a LaTeX-formatted string\n-\n-            - 'latex_inline': Return a LaTeX-formatted string that uses\n-              negative exponents instead of fractions\n-\n-        subfmt : str, optional\n-            Subformat of the result. For the moment, only used for\n-            ``format='latex'`` and ``format='latex_inline'``. Supported\n-            values are:\n-\n-            - 'inline': Use ``$ ... $`` as delimiters.\n-\n-            - 'display': Use ``$\\\\displaystyle ... $`` as delimiters.\n-\n-        Returns\n-        -------\n-        str\n-            A string with the contents of this Quantity\n-        \"\"\"\n-        if unit is not None and unit != self.unit:\n-            return self.to(unit).to_string(\n-                unit=None, precision=precision, format=format, subfmt=subfmt\n-            )\n-\n-        formats = {\n-            None: None,\n-            \"latex\": {\n-                None: (\"$\", \"$\"),\n-                \"inline\": (\"$\", \"$\"),\n-                \"display\": (r\"$\\displaystyle \", r\"$\"),\n-            },\n-        }\n-        formats[\"latex_inline\"] = formats[\"latex\"]\n-\n-        if format not in formats:\n-            raise ValueError(f\"Unknown format '{format}'\")\n-        elif format is None:\n-            if precision is None:\n-                # Use default formatting settings\n-                return f\"{self.value}{self._unitstr:s}\"\n-            else:\n-                # np.array2string properly formats arrays as well as scalars\n-                return (\n-                    np.array2string(self.value, precision=precision, floatmode=\"fixed\")\n-                    + self._unitstr\n-                )\n-\n-        # else, for the moment we assume format=\"latex\" or \"latex_inline\".\n-\n-        # Set the precision if set, otherwise use numpy default\n-        pops = np.get_printoptions()\n-        format_spec = f\".{precision if precision is not None else pops['precision']}g\"\n-\n-        def float_formatter(value):\n-            return Latex.format_exponential_notation(value, format_spec=format_spec)\n-\n-        def complex_formatter(value):\n-            return \"({}{}i)\".format(\n-                Latex.format_exponential_notation(value.real, format_spec=format_spec),\n-                Latex.format_exponential_notation(\n-                    value.imag, format_spec=\"+\" + format_spec\n-                ),\n-            )\n-\n-        # The view is needed for the scalar case - self.value might be float.\n-        latex_value = np.array2string(\n-            self.view(np.ndarray),\n-            threshold=(\n-                conf.latex_array_threshold\n-                if conf.latex_array_threshold > -1\n-                else pops[\"threshold\"]\n-            ),\n-            formatter={\n-                \"float_kind\": float_formatter,\n-                \"complex_kind\": complex_formatter,\n-            },\n-            max_line_width=np.inf,\n-            separator=\",~\",\n-        )\n-\n-        latex_value = latex_value.replace(\"...\", r\"\\dots\")\n-\n-        # Format unit\n-        # [1:-1] strips the '$' on either side needed for math mode\n-        if self.unit is None:\n-            latex_unit = _UNIT_NOT_INITIALISED\n-        elif format == \"latex\":\n-            latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode\n-        elif format == \"latex_inline\":\n-            latex_unit = self.unit.to_string(format=\"latex_inline\")[1:-1]\n-\n-        delimiter_left, delimiter_right = formats[format][subfmt]\n-\n-        return rf\"{delimiter_left}{latex_value} \\; {latex_unit}{delimiter_right}\"\n-\n-    def __str__(self):\n-        return self.to_string()\n-\n-    def __repr__(self):\n-        prefixstr = \"<\" + self.__class__.__name__ + \" \"\n-        arrstr = np.array2string(\n-            self.view(np.ndarray), separator=\", \", prefix=prefixstr\n-        )\n-        return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\n-\n-    def _repr_latex_(self):\n-        \"\"\"\n-        Generate a latex representation of the quantity and its unit.\n-\n-        Returns\n-        -------\n-        lstr\n-            A LaTeX string with the contents of this Quantity\n-        \"\"\"\n-        # NOTE: This should change to display format in a future release\n-        return self.to_string(format=\"latex\", subfmt=\"inline\")\n-\n-    def __format__(self, format_spec):\n-        try:\n-            return self.to_string(format=format_spec)\n-        except ValueError:\n-            # We might have a unit format not implemented in `to_string()`.\n-            if format_spec in Base.registry:\n-                if self.unit is dimensionless_unscaled:\n-                    return f\"{self.value}\"\n-                else:\n-                    return f\"{self.value} {format(self.unit, format_spec)}\"\n-            # Can the value be formatted on its own?\n-            try:\n-                return f\"{format(self.value, format_spec)}{self._unitstr:s}\"\n-            except ValueError:\n-                # Format the whole thing as a single string.\n-                return format(f\"{self.value}{self._unitstr:s}\", format_spec)\n-\n-    def decompose(self, bases=[]):\n-        \"\"\"\n-        Generates a new `Quantity` with the units\n-        decomposed. Decomposed units have only irreducible units in\n-        them (see `astropy.units.UnitBase.decompose`).\n-\n-        Parameters\n-        ----------\n-        bases : sequence of `~astropy.units.UnitBase`, optional\n-            The bases to decompose into.  When not provided,\n-            decomposes down to any irreducible units.  When provided,\n-            the decomposed result will only contain the given units.\n-            This will raises a `~astropy.units.UnitsError` if it's not possible\n-            to do so.\n-\n-        Returns\n-        -------\n-        newq : `~astropy.units.Quantity`\n-            A new object equal to this quantity with units decomposed.\n-        \"\"\"\n-        return self._decompose(False, bases=bases)\n-\n-    def _decompose(self, allowscaledunits=False, bases=[]):\n-        \"\"\"\n-        Generates a new `Quantity` with the units decomposed. Decomposed\n-        units have only irreducible units in them (see\n-        `astropy.units.UnitBase.decompose`).\n-\n-        Parameters\n-        ----------\n-        allowscaledunits : bool\n-            If True, the resulting `Quantity` may have a scale factor\n-            associated with it.  If False, any scaling in the unit will\n-            be subsumed into the value of the resulting `Quantity`\n-\n-        bases : sequence of UnitBase, optional\n-            The bases to decompose into.  When not provided,\n-            decomposes down to any irreducible units.  When provided,\n-            the decomposed result will only contain the given units.\n-            This will raises a `~astropy.units.UnitsError` if it's not possible\n-            to do so.\n-\n-        Returns\n-        -------\n-        newq : `~astropy.units.Quantity`\n-            A new object equal to this quantity with units decomposed.\n-\n-        \"\"\"\n-\n-        new_unit = self.unit.decompose(bases=bases)\n-\n-        # Be careful here because self.value usually is a view of self;\n-        # be sure that the original value is not being modified.\n-        if not allowscaledunits and hasattr(new_unit, \"scale\"):\n-            new_value = self.value * new_unit.scale\n-            new_unit = new_unit / new_unit.scale\n-            return self._new_view(new_value, new_unit)\n-        else:\n-            return self._new_view(self.copy(), new_unit)\n-\n-    # These functions need to be overridden to take into account the units\n-    # Array conversion\n-    # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion\n-\n-    def item(self, *args):\n-        \"\"\"Copy an element of an array to a scalar Quantity and return it.\n-\n-        Like :meth:`~numpy.ndarray.item` except that it always\n-        returns a `Quantity`, not a Python scalar.\n-\n-        \"\"\"\n-        return self._new_view(super().item(*args))\n-\n-    def tolist(self):\n-        raise NotImplementedError(\n-            \"cannot make a list of Quantities. Get list of values with\"\n-            \" q.value.tolist().\"\n-        )\n-\n-    def _to_own_unit(self, value, check_precision=True, *, unit=None):\n-        \"\"\"Convert value to one's own unit (or that given).\n-\n-        Here, non-quantities are treated as dimensionless, and care is taken\n-        for values of 0, infinity or nan, which are allowed to have any unit.\n-\n-        Parameters\n-        ----------\n-        value : anything convertible to `~astropy.units.Quantity`\n-            The value to be converted to the requested unit.\n-        check_precision : bool\n-            Whether to forbit conversion of float to integer if that changes\n-            the input number.  Default: `True`.\n-        unit : `~astropy.units.Unit` or None\n-            The unit to convert to.  By default, the unit of ``self``.\n-\n-        Returns\n-        -------\n-        value : number or `~numpy.ndarray`\n-            In the requested units.\n-\n-        \"\"\"\n-        if unit is None:\n-            unit = self.unit\n-        try:\n-            _value = value.to_value(unit)\n-        except AttributeError:\n-            # We're not a Quantity.\n-            # First remove two special cases (with a fast test):\n-            # 1) Maybe masked printing? MaskedArray with quantities does not\n-            # work very well, but no reason to break even repr and str.\n-            # 2) np.ma.masked? useful if we're a MaskedQuantity.\n-            if value is np.ma.masked or (\n-                value is np.ma.masked_print_option and self.dtype.kind == \"O\"\n-            ):\n-                return value\n-            # Now, let's try a more general conversion.\n-            # Plain arrays will be converted to dimensionless in the process,\n-            # but anything with a unit attribute will use that.\n-            try:\n-                as_quantity = Quantity(value)\n-                _value = as_quantity.to_value(unit)\n-            except UnitsError:\n-                # last chance: if this was not something with a unit\n-                # and is all 0, inf, or nan, we treat it as arbitrary unit.\n-                if not hasattr(value, \"unit\") and can_have_arbitrary_unit(\n-                    as_quantity.value\n-                ):\n-                    _value = as_quantity.value\n-                else:\n-                    raise\n-\n-        if self.dtype.kind == \"i\" and check_precision:\n-            # If, e.g., we are casting float to int, we want to fail if\n-            # precision is lost, but let things pass if it works.\n-            _value = np.array(_value, copy=False, subok=True)\n-            if not np.can_cast(_value.dtype, self.dtype):\n-                self_dtype_array = np.array(_value, self.dtype, subok=True)\n-                if not np.all((self_dtype_array == _value) | np.isnan(_value)):\n-                    raise TypeError(\n-                        \"cannot convert value type to array type without precision loss\"\n-                    )\n-\n-        # Setting names to ensure things like equality work (note that\n-        # above will have failed already if units did not match).\n-        if self.dtype.names:\n-            _value.dtype.names = self.dtype.names\n-        return _value\n-\n-    def itemset(self, *args):\n-        if len(args) == 0:\n-            raise ValueError(\"itemset must have at least one argument\")\n-\n-        self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))\n-\n-    def tostring(self, order=\"C\"):\n-        raise NotImplementedError(\n-            \"cannot write Quantities to string.  Write array with\"\n-            \" q.value.tostring(...).\"\n-        )\n-\n-    def tobytes(self, order=\"C\"):\n-        raise NotImplementedError(\n-            \"cannot write Quantities to bytes.  Write array with q.value.tobytes(...).\"\n-        )\n-\n-    def tofile(self, fid, sep=\"\", format=\"%s\"):\n-        raise NotImplementedError(\n-            \"cannot write Quantities to file.  Write array with q.value.tofile(...)\"\n-        )\n-\n-    def dump(self, file):\n-        raise NotImplementedError(\n-            \"cannot dump Quantities to file.  Write array with q.value.dump()\"\n-        )\n-\n-    def dumps(self):\n-        raise NotImplementedError(\n-            \"cannot dump Quantities to string.  Write array with q.value.dumps()\"\n-        )\n-\n-    # astype, byteswap, copy, view, getfield, setflags OK as is\n-\n-    def fill(self, value):\n-        self.view(np.ndarray).fill(self._to_own_unit(value))\n-\n-    # Shape manipulation: resize cannot be done (does not own data), but\n-    # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only\n-    # the flat iterator needs to be overwritten, otherwise single items are\n-    # returned as numbers.\n-    @property\n-    def flat(self):\n-        \"\"\"A 1-D iterator over the Quantity array.\n-\n-        This returns a ``QuantityIterator`` instance, which behaves the same\n-        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,\n-        and is similar to, but not a subclass of, Python's built-in iterator\n-        object.\n-        \"\"\"\n-        return QuantityIterator(self)\n-\n-    @flat.setter\n-    def flat(self, value):\n-        y = self.ravel()\n-        y[:] = value\n-\n-    # Item selection and manipulation\n-    # repeat, sort, compress, diagonal OK\n-    def take(self, indices, axis=None, out=None, mode=\"raise\"):\n-        out = super().take(indices, axis=axis, out=out, mode=mode)\n-        # For single elements, ndarray.take returns scalars; these\n-        # need a new view as a Quantity.\n-        if type(out) is not type(self):\n-            out = self._new_view(out)\n-        return out\n-\n-    def put(self, indices, values, mode=\"raise\"):\n-        self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)\n-\n-    def choose(self, choices, out=None, mode=\"raise\"):\n-        raise NotImplementedError(\n-            \"cannot choose based on quantity.  Choose using array with\"\n-            \" q.value.choose(...)\"\n-        )\n-\n-    # ensure we do not return indices as quantities\n-    def argsort(self, axis=-1, kind=\"quicksort\", order=None):\n-        return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)\n-\n-    def searchsorted(self, v, *args, **kwargs):\n-        return np.searchsorted(\n-            np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs\n-        )  # avoid numpy 1.6 problem\n-\n-    if NUMPY_LT_1_22:\n-\n-        def argmax(self, axis=None, out=None):\n-            return self.view(np.ndarray).argmax(axis, out=out)\n-\n-        def argmin(self, axis=None, out=None):\n-            return self.view(np.ndarray).argmin(axis, out=out)\n-\n-    else:\n-\n-        def argmax(self, axis=None, out=None, *, keepdims=False):\n-            return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)\n-\n-        def argmin(self, axis=None, out=None, *, keepdims=False):\n-            return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)\n-\n-    def __array_function__(self, function, types, args, kwargs):\n-        \"\"\"Wrap numpy functions, taking care of units.\n-\n-        Parameters\n-        ----------\n-        function : callable\n-            Numpy function to wrap\n-        types : iterable of classes\n-            Classes that provide an ``__array_function__`` override. Can\n-            in principle be used to interact with other classes. Below,\n-            mostly passed on to `~numpy.ndarray`, which can only interact\n-            with subclasses.\n-        args : tuple\n-            Positional arguments provided in the function call.\n-        kwargs : dict\n-            Keyword arguments provided in the function call.\n-\n-        Returns\n-        -------\n-        result: `~astropy.units.Quantity`, `~numpy.ndarray`\n-            As appropriate for the function.  If the function is not\n-            supported, `NotImplemented` is returned, which will lead to\n-            a `TypeError` unless another argument overrode the function.\n-\n-        Raises\n-        ------\n-        ~astropy.units.UnitsError\n-            If operands have incompatible units.\n-        \"\"\"\n-        # A function should be in one of the following sets or dicts:\n-        # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation\n-        #    supports Quantity; we pass on to ndarray.__array_function__.\n-        # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable\n-        #    after converting quantities to arrays with suitable units,\n-        #    and possibly setting units on the result.\n-        # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but\n-        #    requires a Quantity-specific implementation.\n-        # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.\n-        # For now, since we may not yet have complete coverage, if a\n-        # function is in none of the above, we simply call the numpy\n-        # implementation.\n-        if function in SUBCLASS_SAFE_FUNCTIONS:\n-            return super().__array_function__(function, types, args, kwargs)\n-\n-        elif function in FUNCTION_HELPERS:\n-            function_helper = FUNCTION_HELPERS[function]\n-            try:\n-                args, kwargs, unit, out = function_helper(*args, **kwargs)\n-            except NotImplementedError:\n-                return self._not_implemented_or_raise(function, types)\n-\n-            result = super().__array_function__(function, types, args, kwargs)\n-            # Fall through to return section\n-\n-        elif function in DISPATCHED_FUNCTIONS:\n-            dispatched_function = DISPATCHED_FUNCTIONS[function]\n-            try:\n-                result, unit, out = dispatched_function(*args, **kwargs)\n-            except NotImplementedError:\n-                return self._not_implemented_or_raise(function, types)\n-\n-            # Fall through to return section\n-\n-        elif function in UNSUPPORTED_FUNCTIONS:\n-            return NotImplemented\n-\n-        else:\n-            warnings.warn(\n-                f\"function '{function.__name__}' is not known to astropy's Quantity.\"\n-                \" Will run it anyway, hoping it will treat ndarray subclasses\"\n-                \" correctly. Please raise an issue at\"\n-                \" https://github.com/astropy/astropy/issues.\",\n-                AstropyWarning,\n-            )\n-            return super().__array_function__(function, types, args, kwargs)\n-\n-        # If unit is None, a plain array is expected (e.g., boolean), which\n-        # means we're done.\n-        # We're also done if the result was NotImplemented, which can happen\n-        # if other inputs/outputs override __array_function__;\n-        # hopefully, they can then deal with us.\n-        if unit is None or result is NotImplemented:\n-            return result\n-\n-        return self._result_as_quantity(result, unit, out=out)\n-\n-    def _not_implemented_or_raise(self, function, types):\n-        # Our function helper or dispatcher found that the function does not\n-        # work with Quantity.  In principle, there may be another class that\n-        # knows what to do with us, for which we should return NotImplemented.\n-        # But if there is ndarray (or a non-Quantity subclass of it) around,\n-        # it quite likely coerces, so we should just break.\n-        if any(\n-            issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types\n-        ):\n-            raise TypeError(\n-                f\"the Quantity implementation cannot handle {function} \"\n-                \"with the given arguments.\"\n-            ) from None\n-        else:\n-            return NotImplemented\n-\n-    # Calculation -- override ndarray methods to take into account units.\n-    # We use the corresponding numpy functions to evaluate the results, since\n-    # the methods do not always allow calling with keyword arguments.\n-    # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives\n-    # TypeError: 'a_max' is an invalid keyword argument for this function.\n-    def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):\n-        \"\"\"Wrap a numpy function that processes self, returning a Quantity.\n-\n-        Parameters\n-        ----------\n-        function : callable\n-            Numpy function to wrap.\n-        args : positional arguments\n-            Any positional arguments to the function beyond the first argument\n-            (which will be set to ``self``).\n-        kwargs : keyword arguments\n-            Keyword arguments to the function.\n-\n-        If present, the following arguments are treated specially:\n-\n-        unit : `~astropy.units.Unit`\n-            Unit of the output result.  If not given, the unit of ``self``.\n-        out : `~astropy.units.Quantity`\n-            A Quantity instance in which to store the output.\n-\n-        Notes\n-        -----\n-        Output should always be assigned via a keyword argument, otherwise\n-        no proper account of the unit is taken.\n-\n-        Returns\n-        -------\n-        out : `~astropy.units.Quantity`\n-            Result of the function call, with the unit set properly.\n-        \"\"\"\n-        if unit is None:\n-            unit = self.unit\n-        # Ensure we don't loop back by turning any Quantity into array views.\n-        args = (self.value,) + tuple(\n-            (arg.value if isinstance(arg, Quantity) else arg) for arg in args\n-        )\n-        if out is not None:\n-            # If pre-allocated output is used, check it is suitable.\n-            # This also returns array view, to ensure we don't loop back.\n-            arrays = tuple(arg for arg in args if isinstance(arg, np.ndarray))\n-            kwargs[\"out\"] = check_output(out, unit, arrays, function=function)\n-        # Apply the function and turn it back into a Quantity.\n-        result = function(*args, **kwargs)\n-        return self._result_as_quantity(result, unit, out)\n-\n-    def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):\n-        return self._wrap_function(np.trace, offset, axis1, axis2, dtype, out=out)\n-\n-    def var(\n-        self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True\n-    ):\n-        return self._wrap_function(\n-            np.var,\n-            axis,\n-            dtype,\n-            out=out,\n-            ddof=ddof,\n-            keepdims=keepdims,\n-            where=where,\n-            unit=self.unit**2,\n-        )\n-\n-    def std(\n-        self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True\n-    ):\n-        return self._wrap_function(\n-            np.std, axis, dtype, out=out, ddof=ddof, keepdims=keepdims, where=where\n-        )\n-\n-    def mean(self, axis=None, dtype=None, out=None, keepdims=False, *, where=True):\n-        return self._wrap_function(\n-            np.mean, axis, dtype, out=out, keepdims=keepdims, where=where\n-        )\n-\n-    def round(self, decimals=0, out=None):\n-        return self._wrap_function(np.round, decimals, out=out)\n-\n-    def dot(self, b, out=None):\n-        result_unit = self.unit * getattr(b, \"unit\", dimensionless_unscaled)\n-        return self._wrap_function(np.dot, b, out=out, unit=result_unit)\n-\n-    # Calculation: override methods that do not make sense.\n-\n-    def all(self, axis=None, out=None):\n-        raise TypeError(\n-            \"cannot evaluate truth value of quantities. \"\n-            \"Evaluate array with q.value.all(...)\"\n-        )\n-\n-    def any(self, axis=None, out=None):\n-        raise TypeError(\n-            \"cannot evaluate truth value of quantities. \"\n-            \"Evaluate array with q.value.any(...)\"\n-        )\n-\n-    # Calculation: numpy functions that can be overridden with methods.\n-\n-    def diff(self, n=1, axis=-1):\n-        return self._wrap_function(np.diff, n, axis)\n-\n-    def ediff1d(self, to_end=None, to_begin=None):\n-        return self._wrap_function(np.ediff1d, to_end, to_begin)\n-\n-    if NUMPY_LT_1_22:\n-\n-        def nansum(self, axis=None, out=None, keepdims=False):\n-            return self._wrap_function(np.nansum, axis, out=out, keepdims=keepdims)\n-\n-    else:\n-        # TODO: deprecate this method? It is not on ndarray, and we do not\n-        # support nanmean, etc., so why this one?\n-        def nansum(\n-            self, axis=None, out=None, keepdims=False, *, initial=None, where=True\n-        ):\n-            if initial is not None:\n-                initial = self._to_own_unit(initial)\n-            return self._wrap_function(\n-                np.nansum,\n-                axis,\n-                out=out,\n-                keepdims=keepdims,\n-                initial=initial,\n-                where=where,\n-            )\n-\n-    def insert(self, obj, values, axis=None):\n-        \"\"\"\n-        Insert values along the given axis before the given indices and return\n-        a new `~astropy.units.Quantity` object.\n-\n-        This is a thin wrapper around the `numpy.insert` function.\n-\n-        Parameters\n-        ----------\n-        obj : int, slice or sequence of int\n-            Object that defines the index or indices before which ``values`` is\n-            inserted.\n-        values : array-like\n-            Values to insert.  If the type of ``values`` is different\n-            from that of quantity, ``values`` is converted to the matching type.\n-            ``values`` should be shaped so that it can be broadcast appropriately\n-            The unit of ``values`` must be consistent with this quantity.\n-        axis : int, optional\n-            Axis along which to insert ``values``.  If ``axis`` is None then\n-            the quantity array is flattened before insertion.\n-\n-        Returns\n-        -------\n-        out : `~astropy.units.Quantity`\n-            A copy of quantity with ``values`` inserted.  Note that the\n-            insertion does not occur in-place: a new quantity array is returned.\n-\n-        Examples\n-        --------\n-        >>> import astropy.units as u\n-        >>> q = [1, 2] * u.m\n-        >>> q.insert(0, 50 * u.cm)\n-        <Quantity [ 0.5,  1.,  2.] m>\n-\n-        >>> q = [[1, 2], [3, 4]] * u.m\n-        >>> q.insert(1, [10, 20] * u.m, axis=0)\n-        <Quantity [[  1.,  2.],\n-                   [ 10., 20.],\n-                   [  3.,  4.]] m>\n-\n-        >>> q.insert(1, 10 * u.m, axis=1)\n-        <Quantity [[  1., 10.,  2.],\n-                   [  3., 10.,  4.]] m>\n-\n-        \"\"\"\n-        out_array = np.insert(self.value, obj, self._to_own_unit(values), axis)\n-        return self._new_view(out_array)\n-\n-\n-class SpecificTypeQuantity(Quantity):\n-    \"\"\"Superclass for Quantities of specific physical type.\n-\n-    Subclasses of these work just like :class:`~astropy.units.Quantity`, except\n-    that they are for specific physical types (and may have methods that are\n-    only appropriate for that type).  Astropy examples are\n-    :class:`~astropy.coordinates.Angle` and\n-    :class:`~astropy.coordinates.Distance`\n-\n-    At a minimum, subclasses should set ``_equivalent_unit`` to the unit\n-    associated with the physical type.\n-    \"\"\"\n-\n-    # The unit for the specific physical type.  Instances can only be created\n-    # with units that are equivalent to this.\n-    _equivalent_unit = None\n-\n-    # The default unit used for views.  Even with `None`, views of arrays\n-    # without units are possible, but will have an uninitialized unit.\n-    _unit = None\n-\n-    # Default unit for initialization through the constructor.\n-    _default_unit = None\n-\n-    # ensure that we get precedence over our superclass.\n-    __array_priority__ = Quantity.__array_priority__ + 10\n-\n-    def __quantity_subclass__(self, unit):\n-        if unit.is_equivalent(self._equivalent_unit):\n-            return type(self), True\n-        else:\n-            return super().__quantity_subclass__(unit)[0], False\n-\n-    def _set_unit(self, unit):\n-        if unit is None or not unit.is_equivalent(self._equivalent_unit):\n-            raise UnitTypeError(\n-                \"{} instances require units equivalent to '{}'\".format(\n-                    type(self).__name__, self._equivalent_unit\n-                )\n-                + (\n-                    \", but no unit was given.\"\n-                    if unit is None\n-                    else f\", so cannot set it to '{unit}'.\"\n-                )\n-            )\n-\n-        super()._set_unit(unit)\n-\n-\n-def isclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False, **kwargs):\n-    \"\"\"\n-    Return a boolean array where two arrays are element-wise equal\n-    within a tolerance.\n-\n-    Parameters\n-    ----------\n-    a, b : array-like or `~astropy.units.Quantity`\n-        Input values or arrays to compare\n-    rtol : array-like or `~astropy.units.Quantity`\n-        The relative tolerance for the comparison, which defaults to\n-        ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,\n-        then it must be dimensionless.\n-    atol : number or `~astropy.units.Quantity`\n-        The absolute tolerance for the comparison.  The units (or lack\n-        thereof) of ``a``, ``b``, and ``atol`` must be consistent with\n-        each other.  If `None`, ``atol`` defaults to zero in the\n-        appropriate units.\n-    equal_nan : `bool`\n-        Whether to compare NaN\u2019s as equal. If `True`, NaNs in ``a`` will\n-        be considered equal to NaN\u2019s in ``b``.\n-\n-    Notes\n-    -----\n-    This is a :class:`~astropy.units.Quantity`-aware version of\n-    :func:`numpy.isclose`. However, this differs from the `numpy` function in\n-    that the default for the absolute tolerance here is zero instead of\n-    ``atol=1e-8`` in `numpy`, as there is no natural way to set a default\n-    *absolute* tolerance given two inputs that may have differently scaled\n-    units.\n-\n-    Raises\n-    ------\n-    `~astropy.units.UnitsError`\n-        If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,\n-        or if ``rtol`` is not dimensionless.\n-\n-    See also\n-    --------\n-    allclose\n-    \"\"\"\n-    unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)\n-    return np.isclose(*unquantified_args, equal_nan=equal_nan, **kwargs)\n-\n-\n-def allclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False, **kwargs) -> bool:\n-    \"\"\"\n-    Whether two arrays are element-wise equal within a tolerance.\n-\n-    Parameters\n-    ----------\n-    a, b : array-like or `~astropy.units.Quantity`\n-        Input values or arrays to compare\n-    rtol : array-like or `~astropy.units.Quantity`\n-        The relative tolerance for the comparison, which defaults to\n-        ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,\n-        then it must be dimensionless.\n-    atol : number or `~astropy.units.Quantity`\n-        The absolute tolerance for the comparison.  The units (or lack\n-        thereof) of ``a``, ``b``, and ``atol`` must be consistent with\n-        each other.  If `None`, ``atol`` defaults to zero in the\n-        appropriate units.\n-    equal_nan : `bool`\n-        Whether to compare NaN\u2019s as equal. If `True`, NaNs in ``a`` will\n-        be considered equal to NaN\u2019s in ``b``.\n-\n-    Notes\n-    -----\n-    This is a :class:`~astropy.units.Quantity`-aware version of\n-    :func:`numpy.allclose`. However, this differs from the `numpy` function in\n-    that the default for the absolute tolerance here is zero instead of\n-    ``atol=1e-8`` in `numpy`, as there is no natural way to set a default\n-    *absolute* tolerance given two inputs that may have differently scaled\n-    units.\n-\n-    Raises\n-    ------\n-    `~astropy.units.UnitsError`\n-        If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,\n-        or if ``rtol`` is not dimensionless.\n-\n-    See also\n-    --------\n-    isclose\n-    \"\"\"\n-    unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)\n-    return np.allclose(*unquantified_args, equal_nan=equal_nan, **kwargs)\n-\n-\n-def _unquantify_allclose_arguments(actual, desired, rtol, atol):\n-    actual = Quantity(actual, subok=True, copy=False)\n-\n-    desired = Quantity(desired, subok=True, copy=False)\n-    try:\n-        desired = desired.to(actual.unit)\n-    except UnitsError:\n-        raise UnitsError(\n-            f\"Units for 'desired' ({desired.unit}) and 'actual' \"\n-            f\"({actual.unit}) are not convertible\"\n-        )\n-\n-    if atol is None:\n-        # By default, we assume an absolute tolerance of zero in the\n-        # appropriate units.  The default value of None for atol is\n-        # needed because the units of atol must be consistent with the\n-        # units for a and b.\n-        atol = Quantity(0)\n-    else:\n-        atol = Quantity(atol, subok=True, copy=False)\n-        try:\n-            atol = atol.to(actual.unit)\n-        except UnitsError:\n-            raise UnitsError(\n-                f\"Units for 'atol' ({atol.unit}) and 'actual' \"\n-                f\"({actual.unit}) are not convertible\"\n-            )\n-\n-    rtol = Quantity(rtol, subok=True, copy=False)\n-    try:\n-        rtol = rtol.to(dimensionless_unscaled)\n-    except Exception:\n-        raise UnitsError(\"'rtol' should be dimensionless\")\n-\n-    return actual.value, desired.value, rtol.value, atol.value\n+        if result is None: return NotImplemented\n+        if result is None: return NotImplemented\n"}
{"model_name_or_path": "llama", "instance_id": "astropy__astropy-14096", "model_patch": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0..8421eed9e 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -867,13 +867,17 @@ class SkyCoord(ShapedLikeNDArray):\n         )\n \n     def __getattr__(self, attr):\n-        \"\"\"\n+            try:\n+                return getattr(self.__dict__[attr], attr)\n+            except KeyError:\n+                pass\n+            \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n         to, based on the alias attr in the primary transform graph.\n         \"\"\"\n-        if \"_sky_coord_frame\" in self.__dict__:\n-            if self._is_name(attr):\n-                return self  # Should this be a deepcopy of self?\n+            if \"_sky_coord_frame\" in self.__dict__:\n+                if self._is_name(attr):\n+                    return self  # Should this be a deepcopy of self?\n \n             # Anything in the set of all possible frame_attr_names is handled\n             # here. If the attr is relevant for the current frame then delegate\n@@ -895,15 +899,15 @@ class SkyCoord(ShapedLikeNDArray):\n                 return self.transform_to(attr)\n \n         # Fail\n-        raise AttributeError(\n+            raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{attr}'. This might be due to a nested attribute not being found.\")\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n-        )\n+            \n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\n         if \"_sky_coord_frame\" in self.__dict__:\n             if self._is_name(attr):\n-                raise AttributeError(f\"'{attr}' is immutable\")\n+                raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{attr}'. This might be due to a nested attribute not being found.\")\n \n             if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                 setattr(self._sky_coord_frame, attr, val)\n@@ -911,7 +915,7 @@ class SkyCoord(ShapedLikeNDArray):\n \n             frame_cls = frame_transform_graph.lookup_name(attr)\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n-                raise AttributeError(f\"'{attr}' is immutable\")\n+                raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{attr}'. This might be due to a nested attribute not being found.\")\n \n         if attr in frame_transform_graph.frame_attributes:\n             # All possible frame attributes can be set, but only via a private\n@@ -930,7 +934,7 @@ class SkyCoord(ShapedLikeNDArray):\n         # mirror __setattr__ above\n         if \"_sky_coord_frame\" in self.__dict__:\n             if self._is_name(attr):\n-                raise AttributeError(f\"'{attr}' is immutable\")\n+                raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{attr}'. This might be due to a nested attribute not being found.\")\n \n             if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                 delattr(self._sky_coord_frame, attr)\n@@ -938,7 +942,7 @@ class SkyCoord(ShapedLikeNDArray):\n \n             frame_cls = frame_transform_graph.lookup_name(attr)\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n-                raise AttributeError(f\"'{attr}' is immutable\")\n+                raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{attr}'. This might be due to a nested attribute not being found.\")\n \n         if attr in frame_transform_graph.frame_attributes:\n             # All possible frame attributes can be deleted, but need to remove\ndiff --git a/test_skycoord.py b/test_skycoord.py\nnew file mode 100644\nindex 000000000..168b55149\n--- /dev/null\n+++ b/test_skycoord.py\n@@ -0,0 +1,15 @@\n+import astropy.coordinates as coord\n+\n+class custom_coord(coord.SkyCoord):\n+    @property\n+    def prop(self):\n+        try:\n+            return self.random_attr\n+        except AttributeError:\n+            raise AttributeError(\"'random_attr' attribute does not exist\")\n+\n+c = custom_coord('00h42m30s', '+41d12m00s', frame='icrs')\n+try:\n+    c.prop\n+except AttributeError as e:\n+    print(e)\n"}
{"model_name_or_path": "llama", "instance_id": "astropy__astropy-14182", "model_patch": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8ef..0b5d1ad7d 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -37,6 +37,43 @@ class RST(FixedWidth):\n \n     See: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#simple-tables\n \n+    Parameters\n+    ----------\n+    header_rows : list or tuple, optional\n+        List of header rows to include at the top of the table.\n+    \"\"\"\n+    def __init__(self, *args, header_rows=None, **kwargs):\n+        self.header_rows = header_rows\n+        super().__init__(*args, **kwargs)\n+    \"\"\"reStructuredText simple format table.\n+\n+    See: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#simple-tables\n+\n+    Parameters\n+    ----------\n+    header_rows : list or tuple, optional\n+        List of header rows to include at the top of the table.\n+    \"\"\"\n+    def __init__(self, **kwargs):\n+        self.header_rows = kwargs.pop(\"header_rows\", None)\n+        super().__init__(**kwargs)\n+    \"\"\"reStructuredText simple format table.\n+\n+    See: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#simple-tables\n+\n+    Parameters\n+    ----------\n+    header_rows : list or tuple, optional\n+        List of header rows to include at the top of the table.\n+    \"\"\"\n+    def __init__(self, header_rows=None):\n+        if header_rows is not None and not isinstance(header_rows, (list, tuple)):\n+            raise ValueError(\"header_rows must be a list or tuple\")\n+        self.header_rows = header_rows\n+    \"\"\"reStructuredText simple format table.\n+\n+    See: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#simple-tables\n+\n     Example::\n \n         ==== ===== ======\n@@ -61,6 +98,8 @@ class RST(FixedWidth):\n         super().__init__(delimiter_pad=None, bookend=False)\n \n     def write(self, lines):\n+        if self.header_rows is not None:\n+            lines = self.header_rows + lines\n         lines = super().write(lines)\n         lines = [lines[1]] + lines + [lines[1]]\n         return lines\ndiff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex 84d6fed40..1f04af844 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,187 +1,12 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-from io import StringIO\n-\n-from astropy.io import ascii\n-\n-from .common import assert_almost_equal, assert_equal\n-\n-\n-def assert_equal_splitlines(arg1, arg2):\n-    assert_equal(arg1.splitlines(), arg2.splitlines())\n-\n-\n-def test_read_normal():\n-    \"\"\"Normal SimpleRST Table\"\"\"\n-    table = \"\"\"\n-# comment (with blank line above)\n-======= =========\n-   Col1      Col2\n-======= =========\n-   1.2    \"hello\"\n-   2.4  's worlds\n-======= =========\n-\"\"\"\n-    reader = ascii.get_reader(Reader=ascii.RST)\n-    dat = reader.read(table)\n-    assert_equal(dat.colnames, [\"Col1\", \"Col2\"])\n-    assert_almost_equal(dat[1][0], 2.4)\n-    assert_equal(dat[0][1], '\"hello\"')\n-    assert_equal(dat[1][1], \"'s worlds\")\n-\n-\n-def test_read_normal_names():\n-    \"\"\"Normal SimpleRST Table with provided column names\"\"\"\n-    table = \"\"\"\n-# comment (with blank line above)\n-======= =========\n-   Col1      Col2\n-======= =========\n-   1.2    \"hello\"\n-   2.4  's worlds\n-======= =========\n-\"\"\"\n-    reader = ascii.get_reader(Reader=ascii.RST, names=(\"name1\", \"name2\"))\n-    dat = reader.read(table)\n-    assert_equal(dat.colnames, [\"name1\", \"name2\"])\n-    assert_almost_equal(dat[1][0], 2.4)\n-\n-\n-def test_read_normal_names_include():\n-    \"\"\"Normal SimpleRST Table with provided column names\"\"\"\n-    table = \"\"\"\n-# comment (with blank line above)\n-=======  ========== ======\n-   Col1     Col2      Col3\n-=======  ========== ======\n-   1.2     \"hello\"       3\n-   2.4    's worlds      7\n-=======  ========== ======\n-\"\"\"\n-    reader = ascii.get_reader(\n-        Reader=ascii.RST,\n-        names=(\"name1\", \"name2\", \"name3\"),\n-        include_names=(\"name1\", \"name3\"),\n-    )\n-    dat = reader.read(table)\n-    assert_equal(dat.colnames, [\"name1\", \"name3\"])\n-    assert_almost_equal(dat[1][0], 2.4)\n-    assert_equal(dat[0][1], 3)\n-\n-\n-def test_read_normal_exclude():\n-    \"\"\"Nice, typical SimpleRST table with col name excluded\"\"\"\n-    table = \"\"\"\n-======= ==========\n-  Col1     Col2\n-======= ==========\n-  1.2     \"hello\"\n-  2.4    's worlds\n-======= ==========\n-\"\"\"\n-    reader = ascii.get_reader(Reader=ascii.RST, exclude_names=(\"Col1\",))\n-    dat = reader.read(table)\n-    assert_equal(dat.colnames, [\"Col2\"])\n-    assert_equal(dat[1][0], \"'s worlds\")\n-\n-\n-def test_read_unbounded_right_column():\n-    \"\"\"The right hand column should be allowed to overflow\"\"\"\n-    table = \"\"\"\n-# comment (with blank line above)\n-===== ===== ====\n- Col1  Col2 Col3\n-===== ===== ====\n- 1.2    2    Hello\n- 2.4     4   Worlds\n-===== ===== ====\n-\"\"\"\n-    reader = ascii.get_reader(Reader=ascii.RST)\n-    dat = reader.read(table)\n-    assert_equal(dat[0][2], \"Hello\")\n-    assert_equal(dat[1][2], \"Worlds\")\n-\n-\n-def test_read_unbounded_right_column_header():\n-    \"\"\"The right hand column should be allowed to overflow\"\"\"\n-    table = \"\"\"\n-# comment (with blank line above)\n-===== ===== ====\n- Col1  Col2 Col3Long\n-===== ===== ====\n- 1.2    2    Hello\n- 2.4     4   Worlds\n-===== ===== ====\n-\"\"\"\n-    reader = ascii.get_reader(Reader=ascii.RST)\n-    dat = reader.read(table)\n-    assert_equal(dat.colnames[-1], \"Col3Long\")\n-\n-\n-def test_read_right_indented_table():\n-    \"\"\"We should be able to read right indented tables correctly\"\"\"\n-    table = \"\"\"\n-# comment (with blank line above)\n-   ==== ==== ====\n-   Col1 Col2 Col3\n-   ==== ==== ====\n-    3    3.4  foo\n-    1    4.5  bar\n-   ==== ==== ====\n-\"\"\"\n-    reader = ascii.get_reader(Reader=ascii.RST)\n-    dat = reader.read(table)\n-    assert_equal(dat.colnames, [\"Col1\", \"Col2\", \"Col3\"])\n-    assert_equal(dat[0][2], \"foo\")\n-    assert_equal(dat[1][0], 1)\n-\n-\n-def test_trailing_spaces_in_row_definition():\n-    \"\"\"Trailing spaces in the row definition column shouldn't matter\"\"\"\n-    table = (\n-        \"\\n\"\n-        \"# comment (with blank line above)\\n\"\n-        \"   ==== ==== ====    \\n\"\n-        \"   Col1 Col2 Col3\\n\"\n-        \"   ==== ==== ====  \\n\"\n-        \"    3    3.4  foo\\n\"\n-        \"    1    4.5  bar\\n\"\n-        \"   ==== ==== ====  \\n\"\n-    )\n-    # make sure no one accidentally deletes the trailing whitespaces in the\n-    # table.\n-    assert len(table) == 151\n-\n-    reader = ascii.get_reader(Reader=ascii.RST)\n-    dat = reader.read(table)\n-    assert_equal(dat.colnames, [\"Col1\", \"Col2\", \"Col3\"])\n-    assert_equal(dat[0][2], \"foo\")\n-    assert_equal(dat[1][0], 1)\n-\n-\n-table = \"\"\"\\\n-====== =========== ============ ===========\n-  Col1    Col2        Col3        Col4\n-====== =========== ============ ===========\n-  1.2    \"hello\"      1           a\n-  2.4   's worlds          2           2\n-====== =========== ============ ===========\n-\"\"\"\n-dat = ascii.read(table, Reader=ascii.RST)\n-\n-\n-def test_write_normal():\n-    \"\"\"Write a table as a normal SimpleRST Table\"\"\"\n-    out = StringIO()\n-    ascii.write(dat, out, Writer=ascii.RST)\n-    assert_equal_splitlines(\n-        out.getvalue(),\n-        \"\"\"\\\n-==== ========= ==== ====\n-Col1      Col2 Col3 Col4\n-==== ========= ==== ====\n- 1.2   \"hello\"    1    a\n- 2.4 's worlds    2    2\n-==== ========= ==== ====\n-\"\"\",\n-    )\n+from astropy.io.ascii import RST\n+import unittest\n+\n+class TestRSTWriter(unittest.TestCase):\n+    def test_header_rows(self):\n+        writer = RST(header_rows=[\"name\", \"unit\"])\n+        data = [[\"wave\", \"response\"], [350.0, 0.7], [950.0, 1.2]]\n+        output = writer.write(data)\n+        self.assertEqual(output, [\"==== ======\", \"name  unit\", \"==== ======\", \"wave response\", \"==== ======\", \"350.0      0.7\", \"950.0      1.2\", \"==== ======\"])\n+\n+if __name__ == \"__main__\":\n+    unittest.main()\n"}
{"model_name_or_path": "llama", "instance_id": "astropy__astropy-14309", "model_patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex 4b6150f4a..ffc1619db 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,7 +69,7 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n-    return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU)) if args else False isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n \n \n def _decode_mixins(tbl):\n"}
