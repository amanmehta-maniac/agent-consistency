{"instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e2729..76bf115ef 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -212,7 +212,7 @@ def _coord_matrix(model, pos, noutp):\n         for i in range(model.n_inputs):\n             mat[i, i] = 1\n         if pos == 'right':\n-            mat = np.roll(mat, (noutp - model.n_outputs))\n+            mat = np.roll(mat, (noutp - model.n_outputs), axis=0)\n     return mat\n \n \n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13033", "model_patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\nindex c279f35f8..2f3a208dd 100644\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -76,17 +76,34 @@ class BaseTimeSeries(QTable):\n \n             elif self.colnames[:len(required_columns)] != required_columns:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but found '{}'\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n-\n+                # Build a more informative error message when required column checks fail.\n+                # Identify which of the required columns are missing or out of order.\n+                current = self.colnames[:len(required_columns)]\n+                # Determine missing required columns from the full set of colnames\n+                missing = [c for c in required_columns if c not in self.colnames]\n+                if missing:\n+                    raise ValueError(\n+                        \"{} object is invalid - missing required column{} {}\"\n+                        .format(self.__class__.__name__,\n+                                's' if len(missing) > 1 else '',\n+                                ', '.join(\"'{}'\".format(m) for m in missing))\n+                    )\n+                else:\n+                    # If none are missing, the order or placement is incorrect. Provide expected vs found.\n+                    raise ValueError(\n+                        \"{} object is invalid - expected {} as the first column{} but found {}\"\n+                        .format(self.__class__.__name__,\n+                                \"'{}'\".format(required_columns[0]) if len(required_columns) == 1 else \"['{}']\".format(\"', '\".join(required_columns)),\n+                                plural,\n+                                \"'{}'\".format(current[0]) if len(current) == 1 else \"['{}']\".format(\"', '\".join(current)))\n+                    )\n             if (self._required_columns_relax\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):\n                 self._required_columns_relax = False\n-\n     @contextmanager\n     def _delay_required_column_checks(self):\n         self._required_columns_enabled = False\n         yield\n         self._required_columns_enabled = True\n         self._check_required_columns()\n+        self._check_required_columns()\n\\ No newline at end of file\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13236", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127a..7eb0dd52d 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1243,6 +1243,13 @@ class Table:\n         # mixin class\n         if (not isinstance(data, Column) and not data_is_mixin\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n+            import warnings\n+            warnings.warn(\n+                \"Adding a structured numpy array to a Table currently creates an NdarrayMixin. \"\n+                \"In a future release, structured arrays will be added as a Column. \"\n+                \"To ensure forward compatibility, wrap the array in Column before adding.\",\n+                FutureWarning,\n+            )\n             data = data.view(NdarrayMixin)\n             data_is_mixin = True\n \n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13398", "model_patch": "diff --git a/astropy/coordinates/builtin_frames/__init__.py b/astropy/coordinates/builtin_frames/__init__.py\nindex 6fd688c28..17f464246 100644\n--- a/astropy/coordinates/builtin_frames/__init__.py\n+++ b/astropy/coordinates/builtin_frames/__init__.py\n@@ -49,6 +49,7 @@ from . import icrs_cirs_transforms\n from . import cirs_observed_transforms\n from . import icrs_observed_transforms\n from . import intermediate_rotation_transforms\n+from . import itrs_observed_transforms\n from . import ecliptic_transforms\n \n # Import this after importing other frames, since this requires various\ndiff --git a/astropy/coordinates/builtin_frames/itrs_observed_transforms.py b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\nnew file mode 100644\nindex 000000000..3910cbab1\n--- /dev/null\n+++ b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\n@@ -0,0 +1,91 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\"\"\"\n+Contains direct transformation functions between ITRS and observed frames (AltAz, HADec)\n+that remain within ITRS, avoiding geocentric vs topocentric aberration issues.\n+\"\"\"\n+\n+import numpy as np\n+\n+from astropy import units as u\n+from astropy.coordinates.matrix_utilities import rotation_matrix, matrix_transpose\n+from astropy.coordinates.baseframe import frame_transform_graph\n+from astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n+from astropy.coordinates.representation import CartesianRepresentation\n+\n+from .altaz import AltAz\n+from .hadec import HADec\n+from .itrs import ITRS\n+from .utils import PIOVER2\n+\n+\n+def itrs_to_observed_mat(observed_frame):\n+    \"\"\"\n+    Build the rotation matrix that maps ITRS topocentric Cartesian vectors\n+    to the observed frame Cartesian basis (AltAz or HADec).\n+\n+    For AltAz:\n+    - Left-handed: flip x-axis\n+    - Rotate by (pi/2 - latitude) around y to align z with local zenith\n+    - Rotate by longitude around z to align x with local east\n+\n+    For HADec:\n+    - Left-handed: flip y-axis\n+    - Rotate by longitude around z\n+    \"\"\"\n+    lon, lat, _ = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+\n+    if isinstance(observed_frame, AltAz):\n+        elat = lat.to_value(u.radian)\n+        minus_x = np.eye(3)\n+        minus_x[0, 0] = -1.0\n+        mat = (minus_x\n+               @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian)\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    else:\n+        minus_y = np.eye(3)\n+        minus_y[1, 1] = -1.0\n+        mat = (minus_y\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    return mat\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    \"\"\"\n+    Transform an ITRS coordinate to observed (AltAz/HADec) by:\n+    - Treat ITRS position as time invariant: adopt output frame obstime\n+    - Subtract observer ITRS location to get topocentric ITRS vector\n+    - Apply rotation to observed frame Cartesian basis\n+    \"\"\"\n+    # Form the Topocentric ITRS position (use output frame location at its obstime)\n+    # Note: get_itrs does not need obstime here since we remain in ITRS; EarthLocation\n+    # represents a fixed ITRS point.\n+    observer_itrs = observed_frame.location.get_itrs().cartesian\n+    topocentric_itrs_repr = (itrs_coo.cartesian - observer_itrs)\n+    rep = topocentric_itrs_repr.transform(itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+    \"\"\"\n+    Transform an observed coordinate (AltAz/HADec) to ITRS by:\n+    - Rotate observed Cartesian vector back to topocentric ITRS Cartesian basis\n+    - Add observer ITRS location to get geocentric ITRS Cartesian vector\n+    - Realize in the target ITRS frame (adopting its obstime)\n+    \"\"\"\n+    # Back to Topocentric ITRS position\n+    topocentric_itrs_repr = observed_coo.cartesian.transform(\n+        matrix_transpose(itrs_to_observed_mat(observed_coo))\n+    )\n+\n+    # Geocentric ITRS position\n+    observer_itrs = observed_coo.location.get_itrs().cartesian\n+    rep = CartesianRepresentation(topocentric_itrs_repr.x + observer_itrs.x,\n+                                  topocentric_itrs_repr.y + observer_itrs.y,\n+                                  topocentric_itrs_repr.z + observer_itrs.z)\n+\n+    return itrs_frame.realize_frame(rep)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13453", "model_patch": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229c..c7df47367 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -436,10 +436,45 @@ class HTML(core.BaseReader):\n                                     new_cols_escaped.append(col_escaped)\n                                     new_cols.append(new_col)\n                             else:\n-\n-                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n+                                # Apply formatting if provided via the ASCII writer\n+                                # 'formats' argument or via Column.info.format. The\n+                                # BaseData class populates self.data.formats from the\n+                                # write() call, mapping column names to either a\n+                                # format string or a callable.\n+                                fmt_map = getattr(self.data, 'formats', {}) or {}\n+                                fmt = fmt_map.get(col.info.name, None)\n+\n+                                # Helper to get an iterator of string values with the\n+                                # appropriate formatting applied.\n+                                def _iter_str_with_format(_col, _fmt):\n+                                    # If a callable formatter is supplied, apply it to\n+                                    # the raw element values and yield strings. We still\n+                                    # run through fill_values afterwards.\n+                                    if callable(_fmt):\n+                                        # Create a generator of formatted strings\n+                                        def _gen():\n+                                            for val in _col:\n+                                                try:\n+                                                    yield str(_fmt(val))\n+                                                except Exception:\n+                                                    # Fallback to default string if formatter fails\n+                                                    yield str(val)\n+                                        return _gen()\n+                                    elif isinstance(_fmt, str):\n+                                        # Temporarily use the provided format string\n+                                        old_format = _col.info.format\n+                                        _col.info.format = _fmt\n+                                        try:\n+                                            return _col.info.iter_str_vals()\n+                                        finally:\n+                                            _col.info.format = old_format\n+                                    else:\n+                                        # Fall back to column's own format or default\n+                                        return _col.info.iter_str_vals()\n+\n+                                col_iter_vals = _iter_str_with_format(col, fmt if fmt is not None else col.info.format)\n+                                col_iter_str_vals = self.fill_values(col, col_iter_vals)\n                                 col_str_iters.append(col_iter_str_vals)\n-\n                                 new_cols_escaped.append(col_escaped)\n \n                     for row in zip(*col_str_iters):\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13579", "model_patch": "", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13977", "model_patch": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb..2932de97e 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -665,12 +665,17 @@ class Quantity(np.ndarray):\n \n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n-        for input_, converter in zip(inputs, converters):\n-            input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n-\n-        # Call our superclass's __array_ufunc__\n-        result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n+        try:\n+            for input_, converter in zip(inputs, converters):\n+                input_ = getattr(input_, \"value\", input_)\n+                arrays.append(converter(input_) if converter else input_)\n+            # Call our superclass's __array_ufunc__\n+            result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n+        except (ValueError, TypeError):\n+            # If inputs are incompatible (e.g., cannot be converted to the required\n+            # numeric type/unit), prefer deferring to other operands by signaling\n+            # NotImplemented, allowing reflected operations to be attempted.\n+            return NotImplemented\n         # If unit is None, a plain array is expected (e.g., comparisons), which\n         # means we're done.\n         # We're also done if the result was None (for method 'at') or\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14096", "model_patch": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0..b2a6c3798 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -871,6 +871,11 @@ class SkyCoord(ShapedLikeNDArray):\n         Overrides getattr to return coordinates that this can be transformed\n         to, based on the alias attr in the primary transform graph.\n         \"\"\"\n+        # If the attribute is defined on the class (e.g., a property on a subclass),\n+        # access it via normal attribute lookup and propagate any AttributeError it raises.\n+        for cls in self.__class__.mro():\n+            if attr in getattr(cls, '__dict__', {}):\n+                return object.__getattribute__(self, attr)\n         if \"_sky_coord_frame\" in self.__dict__:\n             if self._is_name(attr):\n                 return self  # Should this be a deepcopy of self?\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14182", "model_patch": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8ef..dd3ef6630 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -57,8 +57,17 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, header_rows=None):\n+        \"\"\"\n+        Initialize the RST writer/reader.\n+\n+        Parameters\n+        ----------\n+        header_rows : list or None, optional\n+            A list specifying which column attributes to use as header rows.\n+            If None, defaults to the behavior in FixedWidth (typically [\"name\"]).\n+        \"\"\"\n+        super().__init__(delimiter_pad=None, bookend=False, header_rows=header_rows)\n \n     def write(self, lines):\n         lines = super().write(lines)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14309", "model_patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex 4b6150f4a..8f00d0f2a 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,7 +69,7 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n-    return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    return (len(args) > 0) and isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n \n \n def _decode_mixins(tbl):\n", "model_name_or_path": "gpt5"}
