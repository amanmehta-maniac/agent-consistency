{"instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e2729..45bea3608 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13033", "model_patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\nindex c279f35f8..5227be1c4 100644\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -76,9 +76,28 @@ class BaseTimeSeries(QTable):\n \n             elif self.colnames[:len(required_columns)] != required_columns:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but found '{}'\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n+                # If the first required column is present but some subsequent\n+                # required columns are missing or out of order, provide a clearer\n+                # message indicating which required columns are missing.\n+                if (len(self.colnames) > 0 and\n+                        self.colnames[0] == required_columns[0] and\n+                        len(self.colnames) < len(required_columns)):\n+                    missing = required_columns[len(self.colnames):]\n+                    raise ValueError(\n+                        \"{} object is invalid - missing required column{}: {}\"\n+                        .format(self.__class__.__name__,\n+                                's' if len(missing) > 1 else '',\n+                                \"', '\".join(missing)))\n+\n+                # General mismatch: show expected prefix and the found prefix for clarity.\n+                raise ValueError(\n+                    \"{} object is invalid - expected {} as the first column{} but found {}\"\n+                    .format(self.__class__.__name__,\n+                            \"'{}'\".format(required_columns[0]) if len(required_columns) == 1\n+                            else \"'{}'\".format(\"', '\".join(required_columns)),\n+                            plural,\n+                            \"'{}'\".format(self.colnames[0]) if len(self.colnames) == 1\n+                            else \"'{}'\".format(\"', '\".join(self.colnames[:len(required_columns)]))))\n \n             if (self._required_columns_relax\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13236", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127a..16673f744 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1243,6 +1243,13 @@ class Table:\n         # mixin class\n         if (not isinstance(data, Column) and not data_is_mixin\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n+            import warnings\n+            warnings.warn(\n+                \"Adding a structured numpy array to a Table currently creates an NdarrayMixin. \"\n+                \"Please wrap the data in astropy.table.Column if you intend it to be a Column. \"\n+                \"In a future release (5.2), structured arrays will be added as Column instead of NdarrayMixin.\",\n+                FutureWarning\n+            )\n             data = data.view(NdarrayMixin)\n             data_is_mixin = True\n \n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13398", "model_patch": "diff --git a/astropy/coordinates/builtin_frames/itrs_observed_transforms.py b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\nnew file mode 100644\nindex 000000000..732821c89\n--- /dev/null\n+++ b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\n@@ -0,0 +1,82 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\"\"\"\n+Direct transformations between ITRS and observed frames (AltAz, HADec) that stay within ITRS.\n+These avoid geocentric vs topocentric aberration issues by using purely geometric operations:\n+- Treat ITRS positions as time-invariant (no ITRS->ITRS time referencing).\n+- Convert to topocentric ITRS by subtracting observer EarthLocation ITRS cartesian.\n+- Rotate to/from observed using matrices built from geodetic longitude/latitude.\n+\"\"\"\n+\n+import numpy as np\n+\n+from astropy import units as u\n+from astropy.coordinates.matrix_utilities import rotation_matrix, matrix_transpose\n+from astropy.coordinates.baseframe import frame_transform_graph\n+from astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n+from astropy.coordinates.representation import CartesianRepresentation\n+\n+from .altaz import AltAz\n+from .hadec import HADec\n+from .itrs import ITRS\n+from .utils import PIOVER2\n+\n+\n+def _itrs_to_observed_mat(observed_frame):\n+    \"\"\"\n+    Build rotation matrix from ITRS to observed (AltAz or HADec) frame axes based on\n+    observer geodetic longitude/latitude on WGS84.\n+    \"\"\"\n+    # EarthLocation is with respect to WGS84 in these observed frames\n+    lon, lat, height = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+\n+    if isinstance(observed_frame, AltAz):\n+        # ITRS -> AltAz: left-handed AltAz; x points toward West, y toward South, z up\n+        elat = lat.to_value(u.radian)\n+        minus_x = np.eye(3)\n+        minus_x[0, 0] = -1.0\n+        mat = (minus_x\n+               @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian)\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    else:\n+        # ITRS -> HADec: left-handed HADec; y flipped\n+        minus_y = np.eye(3)\n+        minus_y[1, 1] = -1.0\n+        mat = (minus_y\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    return mat\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    \"\"\"\n+    Transform ITRS to observed (AltAz or HADec) staying within ITRS:\n+    - Do not attempt to synchronize obstimes; treat ITRS positions as time-invariant.\n+    - Compute topocentric ITRS position by subtracting observer ITRS cartesian at its obstime.\n+    - Rotate to observed axes and realize in observed frame.\n+    \"\"\"\n+    # topocentric ITRS vector\n+    observer_itrs = observed_frame.location.get_itrs(obstime=observed_frame.obstime).cartesian\n+    topocentric_itrs = (itrs_coo.represent_as(CartesianRepresentation) - observer_itrs)\n+\n+    rep = topocentric_itrs.transform(_itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+    \"\"\"\n+    Transform observed (AltAz or HADec) to ITRS staying within ITRS:\n+    - Rotate observed cartesian into topocentric ITRS using transpose of the same matrix.\n+    - Add observer ITRS cartesian to get geocentric ITRS position.\n+    - Adopt output ITRS frame obstime without performing ITRS->ITRS time transforms.\n+    \"\"\"\n+    # topocentric ITRS vector from observed\n+    rot = matrix_transpose(_itrs_to_observed_mat(observed_coo))\n+    topocentric_itrs = observed_coo.cartesian.transform(rot)\n+\n+    observer_itrs = observed_coo.location.get_itrs(obstime=itrs_frame.obstime).cartesian\n+    rep = topocentric_itrs + observer_itrs\n+    return itrs_frame.realize_frame(rep)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13453", "model_patch": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229c..644de0f95 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -350,11 +350,17 @@ class HTML(core.BaseReader):\n \n         self.data.header.cols = cols\n \n+        # For formatting setup in BaseData, also set data.cols\n+        self.data.cols = cols\n+\n         if isinstance(self.data.fill_values, tuple):\n             self.data.fill_values = [self.data.fill_values]\n \n         self.data._set_fill_values(cols)\n \n+        # Ensure formats mapping is applied by setting column formats\n+        self.data._set_col_formats()\n+\n         lines = []\n \n         # Set HTML escaping to False for any column in the raw_html_cols input\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13579", "model_patch": "diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\nindex d7605b078..93da17398 100644\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n@@ -244,14 +244,31 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n \n     def world_to_pixel_values(self, *world_arrays):\n         world_arrays = tuple(map(np.asanyarray, world_arrays))\n+        # Build the full set of world arrays expected by the underlying WCS,\n+        # inserting appropriate values for the dropped world dimensions.\n         world_arrays_new = []\n         iworld_curr = -1\n+        # To correctly handle coupled axes, compute the world values\n+        # corresponding to the fixed pixel indices from the slice.\n+        # Evaluate pixel_to_world at the sliced pixel coordinates (with offsets).\n+        pixel_eval = []\n+        ipix_curr = -1\n+        for ipix in range(self._wcs.pixel_n_dim):\n+            slc = self._slices_pixel[ipix]\n+            if isinstance(slc, numbers.Integral):\n+                pixel_eval.append(slc)\n+            else:\n+                start = slc.start if isinstance(slc, slice) else None\n+                pixel_eval.append(0 + start if start is not None else 0)\n+                ipix_curr += 1\n+        ref_world_at_slice = self._wcs.pixel_to_world_values(*pixel_eval)\n+        iworld_curr = -1\n         for iworld in range(self._wcs.world_n_dim):\n             if iworld in self._world_keep:\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n-                world_arrays_new.append(1.)\n+                world_arrays_new.append(np.asanyarray(ref_world_at_slice[iworld]))\n \n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13977", "model_patch": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb..985161f04 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -665,9 +665,15 @@ class Quantity(np.ndarray):\n \n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n-        for input_, converter in zip(inputs, converters):\n-            input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+        try:\n+            for input_, converter in zip(inputs, converters):\n+                input_ = getattr(input_, \"value\", input_)\n+                arrays.append(converter(input_) if converter else input_)\n+        except (TypeError, ValueError):\n+            # If inputs are incompatible for conversion, signal to NumPy that this\n+            # operation is not implemented so that reflected operations on other\n+            # operands may be attempted instead of raising immediately.\n+            return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14096", "model_patch": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0..755308ce6 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -871,6 +871,38 @@ class SkyCoord(ShapedLikeNDArray):\n         Overrides getattr to return coordinates that this can be transformed\n         to, based on the alias attr in the primary transform graph.\n         \"\"\"\n+        # First, attempt standard attribute access. This ensures that if a subclass\n+        # defines an attribute (e.g., a @property) and that attribute raises its own\n+        # AttributeError during evaluation, we propagate that original error rather\n+        # than masking it with the generic SkyCoord missing-attribute message.\n+        # If the attribute truly does not exist, object.__getattribute__ will raise\n+        # AttributeError and we proceed with the SkyCoord-specific dynamic handling.\n+        try:\n+            return object.__getattribute__(self, attr)\n+        except AttributeError:\n+            pass        # If the attribute exists on the class (e.g., as a descriptor/property),\n+        # evaluate it here so that any AttributeError it raises is not masked by\n+        # the generic SkyCoord missing-attribute message.\n+        try:\n+            import inspect\n+            sentinel = object()\n+            cls = type(self)\n+            static_attr = inspect.getattr_static(cls, attr, sentinel)\n+        except Exception:\n+            static_attr = None\n+        if static_attr is not None and static_attr is not sentinel:\n+            # Attribute is defined on the class; access it via the descriptor protocol\n+            # to ensure any inner AttributeError propagates.\n+            try:\n+                obj = getattr(cls, attr)\n+            except AttributeError:\n+                # Fall through to SkyCoord handling if somehow not accessible\n+                obj = None\n+            else:\n+                if hasattr(obj, '__get__'):\n+                    return obj.__get__(self, cls)\n+                return obj\n+\n         if \"_sky_coord_frame\" in self.__dict__:\n             if self._is_name(attr):\n                 return self  # Should this be a deepcopy of self?\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14182", "model_patch": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8ef..6dc5a08e4 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -57,8 +57,12 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, **kwargs):\n+        # Accept and pass through arbitrary keyword arguments (e.g., header_rows)\n+        # to the FixedWidth initializer, while enforcing RST-specific defaults.\n+        # This aligns behavior with other FixedWidth-based writers like\n+        # ascii.fixed_width that already support header_rows in writing.\n+        super().__init__(delimiter_pad=None, bookend=False, **kwargs)\n \n     def write(self, lines):\n         lines = super().write(lines)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14309", "model_patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex 4b6150f4a..1f51fe483 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,7 +69,7 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n-    return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    return len(args) > 0 and isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n \n \n def _decode_mixins(tbl):\n", "model_name_or_path": "gpt5"}
