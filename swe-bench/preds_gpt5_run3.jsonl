{"instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e2729..45bea3608 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13033", "model_patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\nindex c279f35f8..1beed9278 100644\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -70,15 +70,20 @@ class BaseTimeSeries(QTable):\n \n             if not self._required_columns_relax and len(self.colnames) == 0:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but time series has no columns\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural))\n+                raise ValueError(\n+                    \"{} object is invalid - required column{} {} \"\n+                    \"but the time series has no columns\".format(\n+                        self.__class__.__name__, plural, repr(required_columns))\n+                )\n \n             elif self.colnames[:len(required_columns)] != required_columns:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but found '{}'\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n+                found = self.colnames[:len(required_columns)]\n+                raise ValueError(\n+                    \"{} object is invalid - expected leading required column{} {} \"\n+                    \"but found {}\".format(\n+                        self.__class__.__name__, plural, repr(required_columns), repr(found))\n+                )\n \n             if (self._required_columns_relax\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13236", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127a..ea2465d4a 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1243,9 +1243,15 @@ class Table:\n         # mixin class\n         if (not isinstance(data, Column) and not data_is_mixin\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n+            import warnings\n+            warnings.warn(\n+                \"Adding a structured numpy array to Table currently converts it to NdarrayMixin. \"\n+                \"In a future release (5.2), structured arrays will be added as Column instead. \"\n+                \"Please wrap your data in astropy.table.Column to ensure forward compatibility.\",\n+                FutureWarning\n+            )\n             data = data.view(NdarrayMixin)\n             data_is_mixin = True\n-\n         # Get the final column name using precedence.  Some objects may not\n         # have an info attribute. Also avoid creating info as a side effect.\n         if not name:\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13398", "model_patch": "diff --git a/astropy/coordinates/builtin_frames/__init__.py b/astropy/coordinates/builtin_frames/__init__.py\nindex 6fd688c28..17b524478 100644\n--- a/astropy/coordinates/builtin_frames/__init__.py\n+++ b/astropy/coordinates/builtin_frames/__init__.py\n@@ -48,6 +48,7 @@ from . import supergalactic_transforms\n from . import icrs_cirs_transforms\n from . import cirs_observed_transforms\n from . import icrs_observed_transforms\n+from . import itrs_observed_transforms\n from . import intermediate_rotation_transforms\n from . import ecliptic_transforms\n \ndiff --git a/astropy/coordinates/builtin_frames/itrs_observed_transforms.py b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\nnew file mode 100644\nindex 000000000..f450cdea3\n--- /dev/null\n+++ b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\n@@ -0,0 +1,82 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\"\"\"\n+Direct transformation functions between ITRS and observed frames (AltAz, HADec)\n+that remain within ITRS, avoiding geocentric/topocentric aberration confusion.\n+\"\"\"\n+\n+import numpy as np\n+from astropy import units as u\n+from astropy.coordinates.matrix_utilities import rotation_matrix, matrix_transpose\n+from astropy.coordinates.baseframe import frame_transform_graph\n+from astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n+from astropy.coordinates.representation import CartesianRepresentation\n+\n+from .altaz import AltAz\n+from .hadec import HADec\n+from .itrs import ITRS\n+from .utils import PIOVER2\n+\n+def _itrs_to_observed_mat(observed_frame):\n+    \"\"\"\n+    Construct a rotation matrix from ITRS to the observed frame (AltAz or HADec)\n+    based on the observer's geodetic longitude/latitude on WGS84.\n+    \"\"\"\n+    lon, lat, _ = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+\n+    if isinstance(observed_frame, AltAz):\n+        # ITRS to AltAz matrix; AltAz is left-handed\n+        elat = lat.to_value(u.radian)\n+        minus_x = np.eye(3)\n+        minus_x[0][0] = -1.0\n+        mat = (minus_x\n+               @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian)\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    else:\n+        # ITRS to HADec matrix; HADec is left-handed\n+        minus_y = np.eye(3)\n+        minus_y[1][1] = -1.0\n+        mat = (minus_y\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    return mat\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    \"\"\"\n+    Transform from ITRS to AltAz/HADec by:\n+    - Subtracting the observer's ITRS position to get topocentric ITRS.\n+    - Rotating into the observed frame using a matrix based on geodetic lon/lat.\n+    Note: Treat ITRS positions as time-invariant here to avoid SSB-referenced\n+    ITRS->ITRS transforms causing large offsets.\n+    \"\"\"\n+    # Ensure Cartesian for subtraction and rotation\n+    itrs_cart = itrs_coo.cartesian\n+    # Observer geocentric ITRS position\n+    obs_itrs_cart = observed_frame.location.get_itrs().cartesian\n+    # Topocentric ITRS position\n+    topocentric_itrs_repr = CartesianRepresentation(itrs_cart.x - obs_itrs_cart.x,\n+                                                    itrs_cart.y - obs_itrs_cart.y,\n+                                                    itrs_cart.z - obs_itrs_cart.z)\n+    rep = topocentric_itrs_repr.transform(_itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+    \"\"\"\n+    Transform from AltAz/HADec to ITRS by:\n+    - Rotating observed Cartesian back to ITRS using transpose of the matrix.\n+    - Adding the observer's geocentric ITRS position to get geocentric ITRS.\n+    \"\"\"\n+    # Rotate back to topocentric ITRS\n+    topocentric_itrs_repr = observed_coo.cartesian.transform(\n+        matrix_transpose(_itrs_to_observed_mat(observed_coo)))\n+    # Add observer geocentric ITRS position\n+    obs_itrs_cart = observed_coo.location.get_itrs().cartesian\n+    rep = CartesianRepresentation(topocentric_itrs_repr.x + obs_itrs_cart.x,\n+                                  topocentric_itrs_repr.y + obs_itrs_cart.y,\n+                                  topocentric_itrs_repr.z + obs_itrs_cart.z)\n+    return itrs_frame.realize_frame(rep)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13453", "model_patch": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229c..1b9a73582 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -414,8 +414,30 @@ class HTML(core.BaseReader):\n                                 w.data(col.info.name.strip())\n                                 w.end(indent=False)\n                         col_str_iters = []\n+                        # Apply per-column formats passed via write(formats=...)\n+                        try:\n+                            fmts = getattr(self.data, \"formats\", {})\n+                            for _col in cols:\n+                                if _col.info.name in fmts:\n+                                    _col.info.format = fmts[_col.info.name]\n+                        except Exception:\n+                            pass\n                         new_cols_escaped = []\n \n+\n+                        # Ensure that any provided formats={} and fill_values are applied\n+                        # consistently with other ASCII writers. This mirrors the logic\n+                        # in BaseData.str_vals(), which sets column formats from the\n+                        # writer's formats mapping before generating string values.\n+                        try:\n+                            # Apply fill values and formats if available on self.data\n+                            self.data._set_fill_values(cols)\n+                            self.data._set_col_formats()\n+                        except Exception:\n+                            # If for some reason these are not available, continue gracefully.\n+                            pass\n+\n+\n                         # Make a container to hold any new_col objects created\n                         # below for multicolumn elements.  This is purely to\n                         # maintain a reference for these objects during\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13579", "model_patch": "", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13977", "model_patch": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb..421696235 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -640,7 +640,12 @@ class Quantity(np.ndarray):\n         # input to that expected (e.g., radian for np.sin), or to get\n         # consistent units between two inputs (e.g., in np.add) --\n         # and the unit of the result (or tuple of units for nout > 1).\n-        converters, unit = converters_and_unit(function, method, *inputs)\n+        # If this fails due to incompatible inputs, return NotImplemented to\n+        # allow numpy to attempt reflected operations.\n+        try:\n+            converters, unit = converters_and_unit(function, method, *inputs)\n+        except (TypeError, ValueError):\n+            return NotImplemented\n \n         out = kwargs.get(\"out\", None)\n         # Avoid loop back by turning any Quantity output into array views.\n@@ -664,10 +669,15 @@ class Quantity(np.ndarray):\n             )\n \n         # Same for inputs, but here also convert if necessary.\n+        # If conversion fails due to incompatible inputs, return NotImplemented\n+        # to allow numpy to try the reflected operation of the other operand.\n         arrays = []\n-        for input_, converter in zip(inputs, converters):\n-            input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+        try:\n+            for input_, converter in zip(inputs, converters):\n+                input_ = getattr(input_, \"value\", input_)\n+                arrays.append(converter(input_) if converter else input_)\n+        except (TypeError, ValueError):\n+            return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14096", "model_patch": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0..9e8024e6f 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -166,711 +166,28 @@ class SkyCoordInfo(MixinInfo):\n \n \n class SkyCoord(ShapedLikeNDArray):\n-    \"\"\"High-level object providing a flexible interface for celestial coordinate\n-    representation, manipulation, and transformation between systems.\n-\n-    The `SkyCoord` class accepts a wide variety of inputs for initialization. At\n-    a minimum these must provide one or more celestial coordinate values with\n-    unambiguous units.  Inputs may be scalars or lists/tuples/arrays, yielding\n-    scalar or array coordinates (can be checked via ``SkyCoord.isscalar``).\n-    Typically one also specifies the coordinate frame, though this is not\n-    required. The general pattern for spherical representations is::\n-\n-      SkyCoord(COORD, [FRAME], keyword_args ...)\n-      SkyCoord(LON, LAT, [FRAME], keyword_args ...)\n-      SkyCoord(LON, LAT, [DISTANCE], frame=FRAME, unit=UNIT, keyword_args ...)\n-      SkyCoord([FRAME], <lon_attr>=LON, <lat_attr>=LAT, keyword_args ...)\n-\n-    It is also possible to input coordinate values in other representations\n-    such as cartesian or cylindrical.  In this case one includes the keyword\n-    argument ``representation_type='cartesian'`` (for example) along with data\n-    in ``x``, ``y``, and ``z``.\n-\n-    See also: https://docs.astropy.org/en/stable/coordinates/\n-\n-    Examples\n-    --------\n-    The examples below illustrate common ways of initializing a `SkyCoord`\n-    object.  For a complete description of the allowed syntax see the\n-    full coordinates documentation.  First some imports::\n-\n-      >>> from astropy.coordinates import SkyCoord  # High-level coordinates\n-      >>> from astropy.coordinates import ICRS, Galactic, FK4, FK5  # Low-level frames\n-      >>> from astropy.coordinates import Angle, Latitude, Longitude  # Angles\n-      >>> import astropy.units as u\n-\n-    The coordinate values and frame specification can now be provided using\n-    positional and keyword arguments::\n-\n-      >>> c = SkyCoord(10, 20, unit=\"deg\")  # defaults to ICRS frame\n-      >>> c = SkyCoord([1, 2, 3], [-30, 45, 8], frame=\"icrs\", unit=\"deg\")  # 3 coords\n-\n-      >>> coords = [\"1:12:43.2 +31:12:43\", \"1 12 43.2 +31 12 43\"]\n-      >>> c = SkyCoord(coords, frame=FK4, unit=(u.hourangle, u.deg), obstime=\"J1992.21\")\n-\n-      >>> c = SkyCoord(\"1h12m43.2s +1d12m43s\", frame=Galactic)  # Units from string\n-      >>> c = SkyCoord(frame=\"galactic\", l=\"1h12m43.2s\", b=\"+1d12m43s\")\n-\n-      >>> ra = Longitude([1, 2, 3], unit=u.deg)  # Could also use Angle\n-      >>> dec = np.array([4.5, 5.2, 6.3]) * u.deg  # Astropy Quantity\n-      >>> c = SkyCoord(ra, dec, frame='icrs')\n-      >>> c = SkyCoord(frame=ICRS, ra=ra, dec=dec, obstime='2001-01-02T12:34:56')\n-\n-      >>> c = FK4(1 * u.deg, 2 * u.deg)  # Uses defaults for obstime, equinox\n-      >>> c = SkyCoord(c, obstime='J2010.11', equinox='B1965')  # Override defaults\n-\n-      >>> c = SkyCoord(w=0, u=1, v=2, unit='kpc', frame='galactic',\n-      ...              representation_type='cartesian')\n-\n-      >>> c = SkyCoord([ICRS(ra=1*u.deg, dec=2*u.deg), ICRS(ra=3*u.deg, dec=4*u.deg)])\n-\n-    Velocity components (proper motions or radial velocities) can also be\n-    provided in a similar manner::\n-\n-      >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, radial_velocity=10*u.km/u.s)\n-\n-      >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, pm_ra_cosdec=2*u.mas/u.yr, pm_dec=1*u.mas/u.yr)\n-\n-    As shown, the frame can be a `~astropy.coordinates.BaseCoordinateFrame`\n-    class or the corresponding string alias.  The frame classes that are built in\n-    to astropy are `ICRS`, `FK5`, `FK4`, `FK4NoETerms`, and `Galactic`.\n-    The string aliases are simply lower-case versions of the class name, and\n-    allow for creating a `SkyCoord` object and transforming frames without\n-    explicitly importing the frame classes.\n-\n-    Parameters\n-    ----------\n-    frame : `~astropy.coordinates.BaseCoordinateFrame` class or string, optional\n-        Type of coordinate frame this `SkyCoord` should represent. Defaults to\n-        to ICRS if not given or given as None.\n-    unit : `~astropy.units.Unit`, string, or tuple of :class:`~astropy.units.Unit` or str, optional\n-        Units for supplied coordinate values.\n-        If only one unit is supplied then it applies to all values.\n-        Note that passing only one unit might lead to unit conversion errors\n-        if the coordinate values are expected to have mixed physical meanings\n-        (e.g., angles and distances).\n-    obstime : time-like, optional\n-        Time(s) of observation.\n-    equinox : time-like, optional\n-        Coordinate frame equinox time.\n-    representation_type : str or Representation class\n-        Specifies the representation, e.g. 'spherical', 'cartesian', or\n-        'cylindrical'.  This affects the positional args and other keyword args\n-        which must correspond to the given representation.\n-    copy : bool, optional\n-        If `True` (default), a copy of any coordinate data is made.  This\n-        argument can only be passed in as a keyword argument.\n-    **keyword_args\n-        Other keyword arguments as applicable for user-defined coordinate frames.\n-        Common options include:\n-\n-        ra, dec : angle-like, optional\n-            RA and Dec for frames where ``ra`` and ``dec`` are keys in the\n-            frame's ``representation_component_names``, including `ICRS`,\n-            `FK5`, `FK4`, and `FK4NoETerms`.\n-        pm_ra_cosdec, pm_dec  : `~astropy.units.Quantity` ['angular speed'], optional\n-            Proper motion components, in angle per time units.\n-        l, b : angle-like, optional\n-            Galactic ``l`` and ``b`` for for frames where ``l`` and ``b`` are\n-            keys in the frame's ``representation_component_names``, including\n-            the `Galactic` frame.\n-        pm_l_cosb, pm_b : `~astropy.units.Quantity` ['angular speed'], optional\n-            Proper motion components in the `Galactic` frame, in angle per time\n-            units.\n-        x, y, z : float or `~astropy.units.Quantity` ['length'], optional\n-            Cartesian coordinates values\n-        u, v, w : float or `~astropy.units.Quantity` ['length'], optional\n-            Cartesian coordinates values for the Galactic frame.\n-        radial_velocity : `~astropy.units.Quantity` ['speed'], optional\n-            The component of the velocity along the line-of-sight (i.e., the\n-            radial direction), in velocity units.\n-    \"\"\"\n-\n-    # Declare that SkyCoord can be used as a Table column by defining the\n-    # info property.\n-    info = SkyCoordInfo()\n-\n-    def __init__(self, *args, copy=True, **kwargs):\n-        # these are frame attributes set on this SkyCoord but *not* a part of\n-        # the frame object this SkyCoord contains\n-        self._extra_frameattr_names = set()\n-\n-        # If all that is passed in is a frame instance that already has data,\n-        # we should bypass all of the parsing and logic below. This is here\n-        # to make this the fastest way to create a SkyCoord instance. Many of\n-        # the classmethods implemented for performance enhancements will use\n-        # this as the initialization path\n-        if (\n-            len(args) == 1\n-            and len(kwargs) == 0\n-            and isinstance(args[0], (BaseCoordinateFrame, SkyCoord))\n-        ):\n-            coords = args[0]\n-            if isinstance(coords, SkyCoord):\n-                self._extra_frameattr_names = coords._extra_frameattr_names\n-                self.info = coords.info\n-\n-                # Copy over any extra frame attributes\n-                for attr_name in self._extra_frameattr_names:\n-                    # Setting it will also validate it.\n-                    setattr(self, attr_name, getattr(coords, attr_name))\n-\n-                coords = coords.frame\n-\n-            if not coords.has_data:\n-                raise ValueError(\n-                    \"Cannot initialize from a coordinate frame \"\n-                    \"instance without coordinate data\"\n-                )\n-\n-            if copy:\n-                self._sky_coord_frame = coords.copy()\n-            else:\n-                self._sky_coord_frame = coords\n-\n-        else:\n-            # Get the frame instance without coordinate data but with all frame\n-            # attributes set - these could either have been passed in with the\n-            # frame as an instance, or passed in as kwargs here\n-            frame_cls, frame_kwargs = _get_frame_without_data(args, kwargs)\n-\n-            # Parse the args and kwargs to assemble a sanitized and validated\n-            # kwargs dict for initializing attributes for this object and for\n-            # creating the internal self._sky_coord_frame object\n-            args = list(args)  # Make it mutable\n-            skycoord_kwargs, components, info = _parse_coordinate_data(\n-                frame_cls(**frame_kwargs), args, kwargs\n-            )\n-\n-            # In the above two parsing functions, these kwargs were identified\n-            # as valid frame attributes for *some* frame, but not the frame that\n-            # this SkyCoord will have. We keep these attributes as special\n-            # skycoord frame attributes:\n-            for attr in skycoord_kwargs:\n-                # Setting it will also validate it.\n-                setattr(self, attr, skycoord_kwargs[attr])\n-\n-            if info is not None:\n-                self.info = info\n-\n-            # Finally make the internal coordinate object.\n-            frame_kwargs.update(components)\n-            self._sky_coord_frame = frame_cls(copy=copy, **frame_kwargs)\n-\n-            if not self._sky_coord_frame.has_data:\n-                raise ValueError(\"Cannot create a SkyCoord without data\")\n-\n-    @property\n-    def frame(self):\n-        return self._sky_coord_frame\n-\n-    @property\n-    def representation_type(self):\n-        return self.frame.representation_type\n-\n-    @representation_type.setter\n-    def representation_type(self, value):\n-        self.frame.representation_type = value\n-\n-    # TODO: remove these in future\n-    @property\n-    def representation(self):\n-        return self.frame.representation\n-\n-    @representation.setter\n-    def representation(self, value):\n-        self.frame.representation = value\n-\n-    @property\n-    def shape(self):\n-        return self.frame.shape\n-\n-    def __eq__(self, value):\n-        \"\"\"Equality operator for SkyCoord\n-\n-        This implements strict equality and requires that the frames are\n-        equivalent, extra frame attributes are equivalent, and that the\n-        representation data are exactly equal.\n-        \"\"\"\n-\n-        if isinstance(value, BaseCoordinateFrame):\n-            if value._data is None:\n-                raise ValueError(\"Can only compare SkyCoord to Frame with data\")\n-\n-            return self.frame == value\n-\n-        if not isinstance(value, SkyCoord):\n-            return NotImplemented\n-\n-        # Make sure that any extra frame attribute names are equivalent.\n-        for attr in self._extra_frameattr_names | value._extra_frameattr_names:\n-            if not self.frame._frameattr_equiv(\n-                getattr(self, attr), getattr(value, attr)\n-            ):\n-                raise ValueError(\n-                    f\"cannot compare: extra frame attribute '{attr}' is not equivalent\"\n-                    \" (perhaps compare the frames directly to avoid this exception)\"\n-                )\n-\n-        return self._sky_coord_frame == value._sky_coord_frame\n-\n-    def __ne__(self, value):\n-        return np.logical_not(self == value)\n-\n-    def _apply(self, method, *args, **kwargs):\n-        \"\"\"Create a new instance, applying a method to the underlying data.\n-\n-        In typical usage, the method is any of the shape-changing methods for\n-        `~numpy.ndarray` (``reshape``, ``swapaxes``, etc.), as well as those\n-        picking particular elements (``__getitem__``, ``take``, etc.), which\n-        are all defined in `~astropy.utils.shapes.ShapedLikeNDArray`. It will be\n-        applied to the underlying arrays in the representation (e.g., ``x``,\n-        ``y``, and ``z`` for `~astropy.coordinates.CartesianRepresentation`),\n-        as well as to any frame attributes that have a shape, with the results\n-        used to create a new instance.\n-\n-        Internally, it is also used to apply functions to the above parts\n-        (in particular, `~numpy.broadcast_to`).\n-\n-        Parameters\n-        ----------\n-        method : str or callable\n-            If str, it is the name of a method that is applied to the internal\n-            ``components``. If callable, the function is applied.\n-        *args\n-            Any positional arguments for ``method``.\n-        **kwargs : dict\n-            Any keyword arguments for ``method``.\n-        \"\"\"\n-\n-        def apply_method(value):\n-            if isinstance(value, ShapedLikeNDArray):\n-                return value._apply(method, *args, **kwargs)\n-            else:\n-                if callable(method):\n-                    return method(value, *args, **kwargs)\n-                else:\n-                    return getattr(value, method)(*args, **kwargs)\n-\n-        # create a new but empty instance, and copy over stuff\n-        new = super().__new__(self.__class__)\n-        new._sky_coord_frame = self._sky_coord_frame._apply(method, *args, **kwargs)\n-        new._extra_frameattr_names = self._extra_frameattr_names.copy()\n-        for attr in self._extra_frameattr_names:\n-            value = getattr(self, attr)\n-            if getattr(value, \"shape\", ()):\n-                value = apply_method(value)\n-            elif method == \"copy\" or method == \"flatten\":\n-                # flatten should copy also for a single element array, but\n-                # we cannot use it directly for array scalars, since it\n-                # always returns a one-dimensional array. So, just copy.\n-                value = copy.copy(value)\n-            setattr(new, \"_\" + attr, value)\n-\n-        # Copy other 'info' attr only if it has actually been defined.\n-        # See PR #3898 for further explanation and justification, along\n-        # with Quantity.__array_finalize__\n-        if \"info\" in self.__dict__:\n-            new.info = self.info\n-\n-        return new\n-\n-    def __setitem__(self, item, value):\n-        \"\"\"Implement self[item] = value for SkyCoord\n-\n-        The right hand ``value`` must be strictly consistent with self:\n-        - Identical class\n-        - Equivalent frames\n-        - Identical representation_types\n-        - Identical representation differentials keys\n-        - Identical frame attributes\n-        - Identical \"extra\" frame attributes (e.g. obstime for an ICRS coord)\n-\n-        With these caveats the setitem ends up as effectively a setitem on\n-        the representation data.\n-\n-          self.frame.data[item] = value.frame.data\n-        \"\"\"\n-        if self.__class__ is not value.__class__:\n-            raise TypeError(\n-                \"can only set from object of same class: \"\n-                f\"{self.__class__.__name__} vs. {value.__class__.__name__}\"\n-            )\n-\n-        # Make sure that any extra frame attribute names are equivalent.\n-        for attr in self._extra_frameattr_names | value._extra_frameattr_names:\n-            if not self.frame._frameattr_equiv(\n-                getattr(self, attr), getattr(value, attr)\n-            ):\n-                raise ValueError(f\"attribute {attr} is not equivalent\")\n-\n-        # Set the frame values.  This checks frame equivalence and also clears\n-        # the cache to ensure that the object is not in an inconsistent state.\n-        self._sky_coord_frame[item] = value._sky_coord_frame\n-\n-    def insert(self, obj, values, axis=0):\n-        \"\"\"\n-        Insert coordinate values before the given indices in the object and\n-        return a new Frame object.\n-\n-        The values to be inserted must conform to the rules for in-place setting\n-        of ``SkyCoord`` objects.\n-\n-        The API signature matches the ``np.insert`` API, but is more limited.\n-        The specification of insert index ``obj`` must be a single integer,\n-        and the ``axis`` must be ``0`` for simple insertion before the index.\n-\n-        Parameters\n-        ----------\n-        obj : int\n-            Integer index before which ``values`` is inserted.\n-        values : array-like\n-            Value(s) to insert.  If the type of ``values`` is different\n-            from that of quantity, ``values`` is converted to the matching type.\n-        axis : int, optional\n-            Axis along which to insert ``values``.  Default is 0, which is the\n-            only allowed value and will insert a row.\n-\n-        Returns\n-        -------\n-        out : `~astropy.coordinates.SkyCoord` instance\n-            New coordinate object with inserted value(s)\n-\n-        \"\"\"\n-        # Validate inputs: obj arg is integer, axis=0, self is not a scalar, and\n-        # input index is in bounds.\n-        try:\n-            idx0 = operator.index(obj)\n-        except TypeError:\n-            raise TypeError(\"obj arg must be an integer\")\n-\n-        if axis != 0:\n-            raise ValueError(\"axis must be 0\")\n-\n-        if not self.shape:\n-            raise TypeError(\n-                f\"cannot insert into scalar {self.__class__.__name__} object\"\n-            )\n-\n-        if abs(idx0) > len(self):\n-            raise IndexError(\n-                f\"index {idx0} is out of bounds for axis 0 with size {len(self)}\"\n-            )\n-\n-        # Turn negative index into positive\n-        if idx0 < 0:\n-            idx0 = len(self) + idx0\n-\n-        n_values = len(values) if values.shape else 1\n-\n-        # Finally make the new object with the correct length and set values for the\n-        # three sections, before insert, the insert, and after the insert.\n-        out = self.__class__.info.new_like(\n-            [self], len(self) + n_values, name=self.info.name\n-        )\n-\n-        # Set the output values. This is where validation of `values` takes place to ensure\n-        # that it can indeed be inserted.\n-        out[:idx0] = self[:idx0]\n-        out[idx0 : idx0 + n_values] = values\n-        out[idx0 + n_values :] = self[idx0:]\n \n-        return out\n-\n-    def is_transformable_to(self, new_frame):\n-        \"\"\"\n-        Determines if this coordinate frame can be transformed to another\n-        given frame.\n-\n-        Parameters\n-        ----------\n-        new_frame : frame class, frame object, or str\n-            The proposed frame to transform into.\n-\n-        Returns\n-        -------\n-        transformable : bool or str\n-            `True` if this can be transformed to ``new_frame``, `False` if\n-            not, or the string 'same' if ``new_frame`` is the same system as\n-            this object but no transformation is defined.\n-\n-        Notes\n-        -----\n-        A return value of 'same' means the transformation will work, but it will\n-        just give back a copy of this object.  The intended usage is::\n-\n-            if coord.is_transformable_to(some_unknown_frame):\n-                coord2 = coord.transform_to(some_unknown_frame)\n-\n-        This will work even if ``some_unknown_frame``  turns out to be the same\n-        frame class as ``coord``.  This is intended for cases where the frame\n-        is the same regardless of the frame attributes (e.g. ICRS), but be\n-        aware that it *might* also indicate that someone forgot to define the\n-        transformation between two objects of the same frame class but with\n-        different attributes.\n-        \"\"\"\n-        # TODO! like matplotlib, do string overrides for modified methods\n-        new_frame = (\n-            _get_frame_class(new_frame) if isinstance(new_frame, str) else new_frame\n-        )\n-        return self.frame.is_transformable_to(new_frame)\n-\n-    def transform_to(self, frame, merge_attributes=True):\n-        \"\"\"Transform this coordinate to a new frame.\n-\n-        The precise frame transformed to depends on ``merge_attributes``.\n-        If `False`, the destination frame is used exactly as passed in.\n-        But this is often not quite what one wants.  E.g., suppose one wants to\n-        transform an ICRS coordinate that has an obstime attribute to FK4; in\n-        this case, one likely would want to use this information. Thus, the\n-        default for ``merge_attributes`` is `True`, in which the precedence is\n-        as follows: (1) explicitly set (i.e., non-default) values in the\n-        destination frame; (2) explicitly set values in the source; (3) default\n-        value in the destination frame.\n-\n-        Note that in either case, any explicitly set attributes on the source\n-        `SkyCoord` that are not part of the destination frame's definition are\n-        kept (stored on the resulting `SkyCoord`), and thus one can round-trip\n-        (e.g., from FK4 to ICRS to FK4 without losing obstime).\n-\n-        Parameters\n-        ----------\n-        frame : str, `BaseCoordinateFrame` class or instance, or `SkyCoord` instance\n-            The frame to transform this coordinate into.  If a `SkyCoord`, the\n-            underlying frame is extracted, and all other information ignored.\n-        merge_attributes : bool, optional\n-            Whether the default attributes in the destination frame are allowed\n-            to be overridden by explicitly set attributes in the source\n-            (see note above; default: `True`).\n-\n-        Returns\n-        -------\n-        coord : `SkyCoord`\n-            A new object with this coordinate represented in the `frame` frame.\n-\n-        Raises\n-        ------\n-        ValueError\n-            If there is no possible transformation route.\n-\n-        \"\"\"\n-        from astropy.coordinates.errors import ConvertError\n-\n-        frame_kwargs = {}\n-\n-        # Frame name (string) or frame class?  Coerce into an instance.\n+    def __getattribute__(self, attr):\n         try:\n-            frame = _get_frame_class(frame)()\n-        except Exception:\n-            pass\n-\n-        if isinstance(frame, SkyCoord):\n-            frame = frame.frame  # Change to underlying coord frame instance\n-\n-        if isinstance(frame, BaseCoordinateFrame):\n-            new_frame_cls = frame.__class__\n-            # Get frame attributes, allowing defaults to be overridden by\n-            # explicitly set attributes of the source if ``merge_attributes``.\n-            for attr in frame_transform_graph.frame_attributes:\n-                self_val = getattr(self, attr, None)\n-                frame_val = getattr(frame, attr, None)\n-                if frame_val is not None and not (\n-                    merge_attributes and frame.is_frame_attr_default(attr)\n-                ):\n-                    frame_kwargs[attr] = frame_val\n-                elif self_val is not None and not self.is_frame_attr_default(attr):\n-                    frame_kwargs[attr] = self_val\n-                elif frame_val is not None:\n-                    frame_kwargs[attr] = frame_val\n-        else:\n-            raise ValueError(\n-                \"Transform `frame` must be a frame name, class, or instance\"\n-            )\n-\n-        # Get the composite transform to the new frame\n-        trans = frame_transform_graph.get_transform(self.frame.__class__, new_frame_cls)\n-        if trans is None:\n-            raise ConvertError(\n-                f\"Cannot transform from {self.frame.__class__} to {new_frame_cls}\"\n-            )\n-\n-        # Make a generic frame which will accept all the frame kwargs that\n-        # are provided and allow for transforming through intermediate frames\n-        # which may require one or more of those kwargs.\n-        generic_frame = GenericFrame(frame_kwargs)\n-\n-        # Do the transformation, returning a coordinate frame of the desired\n-        # final type (not generic).\n-        new_coord = trans(self.frame, generic_frame)\n-\n-        # Finally make the new SkyCoord object from the `new_coord` and\n-        # remaining frame_kwargs that are not frame_attributes in `new_coord`.\n-        for attr in set(new_coord.frame_attributes) & set(frame_kwargs.keys()):\n-            frame_kwargs.pop(attr)\n-\n-        # Always remove the origin frame attribute, as that attribute only makes\n-        # sense with a SkyOffsetFrame (in which case it will be stored on the frame).\n-        # See gh-11277.\n-        # TODO: Should it be a property of the frame attribute that it can\n-        # or cannot be stored on a SkyCoord?\n-        frame_kwargs.pop(\"origin\", None)\n-\n-        return self.__class__(new_coord, **frame_kwargs)\n-\n-    def apply_space_motion(self, new_obstime=None, dt=None):\n-        \"\"\"\n-        Compute the position of the source represented by this coordinate object\n-        to a new time using the velocities stored in this object and assuming\n-        linear space motion (including relativistic corrections). This is\n-        sometimes referred to as an \"epoch transformation.\"\n-\n-        The initial time before the evolution is taken from the ``obstime``\n-        attribute of this coordinate.  Note that this method currently does not\n-        support evolving coordinates where the *frame* has an ``obstime`` frame\n-        attribute, so the ``obstime`` is only used for storing the before and\n-        after times, not actually as an attribute of the frame. Alternatively,\n-        if ``dt`` is given, an ``obstime`` need not be provided at all.\n-\n-        Parameters\n-        ----------\n-        new_obstime : `~astropy.time.Time`, optional\n-            The time at which to evolve the position to. Requires that the\n-            ``obstime`` attribute be present on this frame.\n-        dt : `~astropy.units.Quantity`, `~astropy.time.TimeDelta`, optional\n-            An amount of time to evolve the position of the source. Cannot be\n-            given at the same time as ``new_obstime``.\n-\n-        Returns\n-        -------\n-        new_coord : `SkyCoord`\n-            A new coordinate object with the evolved location of this coordinate\n-            at the new time.  ``obstime`` will be set on this object to the new\n-            time only if ``self`` also has ``obstime``.\n-        \"\"\"\n-        from .builtin_frames.icrs import ICRS\n-\n-        if (new_obstime is None) == (dt is None):\n-            raise ValueError(\n-                \"You must specify one of `new_obstime` or `dt`, but not both.\"\n-            )\n-\n-        # Validate that we have velocity info\n-        if \"s\" not in self.frame.data.differentials:\n-            raise ValueError(\"SkyCoord requires velocity data to evolve the position.\")\n-\n-        if \"obstime\" in self.frame.frame_attributes:\n-            raise NotImplementedError(\n-                \"Updating the coordinates in a frame with explicit time dependence is\"\n-                \" currently not supported. If you would like this functionality, please\"\n-                \" open an issue on github:\\nhttps://github.com/astropy/astropy\"\n-            )\n-\n-        if new_obstime is not None and self.obstime is None:\n-            # If no obstime is already on this object, raise an error if a new\n-            # obstime is passed: we need to know the time / epoch at which the\n-            # the position / velocity were measured initially\n-            raise ValueError(\n-                \"This object has no associated `obstime`. apply_space_motion() must\"\n-                \" receive a time difference, `dt`, and not a new obstime.\"\n-            )\n-\n-        # Compute t1 and t2, the times used in the starpm call, which *only*\n-        # uses them to compute a delta-time\n-        t1 = self.obstime\n-        if dt is None:\n-            # self.obstime is not None and new_obstime is not None b/c of above\n-            # checks\n-            t2 = new_obstime\n-        else:\n-            # new_obstime is definitely None b/c of the above checks\n-            if t1 is None:\n-                # MAGIC NUMBER: if the current SkyCoord object has no obstime,\n-                # assume J2000 to do the dt offset. This is not actually used\n-                # for anything except a delta-t in starpm, so it's OK that it's\n-                # not necessarily the \"real\" obstime\n-                t1 = Time(\"J2000\")\n-                new_obstime = None  # we don't actually know the initial obstime\n-                t2 = t1 + dt\n-            else:\n-                t2 = t1 + dt\n-                new_obstime = t2\n-        # starpm wants tdb time\n-        t1 = t1.tdb\n-        t2 = t2.tdb\n-\n-        # proper motion in RA should not include the cos(dec) term, see the\n-        # erfa function eraStarpv, comment (4).  So we convert to the regular\n-        # spherical differentials.\n-        icrsrep = self.icrs.represent_as(SphericalRepresentation, SphericalDifferential)\n-        icrsvel = icrsrep.differentials[\"s\"]\n-\n-        parallax_zero = False\n-        try:\n-            plx = icrsrep.distance.to_value(u.arcsecond, u.parallax())\n-        except u.UnitConversionError:  # No distance: set to 0 by convention\n-            plx = 0.0\n-            parallax_zero = True\n-\n-        try:\n-            rv = icrsvel.d_distance.to_value(u.km / u.s)\n-        except u.UnitConversionError:  # No RV\n-            rv = 0.0\n-\n-        starpm = erfa.pmsafe(\n-            icrsrep.lon.radian,\n-            icrsrep.lat.radian,\n-            icrsvel.d_lon.to_value(u.radian / u.yr),\n-            icrsvel.d_lat.to_value(u.radian / u.yr),\n-            plx,\n-            rv,\n-            t1.jd1,\n-            t1.jd2,\n-            t2.jd1,\n-            t2.jd2,\n-        )\n-\n-        if parallax_zero:\n-            new_distance = None\n-        else:\n-            new_distance = Distance(parallax=starpm[4] << u.arcsec)\n-\n-        icrs2 = ICRS(\n-            ra=u.Quantity(starpm[0], u.radian, copy=False),\n-            dec=u.Quantity(starpm[1], u.radian, copy=False),\n-            pm_ra=u.Quantity(starpm[2], u.radian / u.yr, copy=False),\n-            pm_dec=u.Quantity(starpm[3], u.radian / u.yr, copy=False),\n-            distance=new_distance,\n-            radial_velocity=u.Quantity(starpm[5], u.km / u.s, copy=False),\n-            differential_type=SphericalDifferential,\n-        )\n-\n-        # Update the obstime of the returned SkyCoord, and need to carry along\n-        # the frame attributes\n-        frattrs = {\n-            attrnm: getattr(self, attrnm) for attrnm in self._extra_frameattr_names\n-        }\n-        frattrs[\"obstime\"] = new_obstime\n-        result = self.__class__(icrs2, **frattrs).transform_to(self.frame)\n-\n-        # Without this the output might not have the right differential type.\n-        # Not sure if this fixes the problem or just hides it.  See #11932\n-        result.differential_type = self.differential_type\n-\n-        return result\n-\n-    def _is_name(self, string):\n-        \"\"\"\n-        Returns whether a string is one of the aliases for the frame.\n-        \"\"\"\n-        return self.frame.name == string or (\n-            isinstance(self.frame.name, list) and string in self.frame.name\n-        )\n+            return object.__getattribute__(self, attr)\n+        except AttributeError:\n+            return self.__getattr__(attr)\n \n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n         to, based on the alias attr in the primary transform graph.\n         \"\"\"\n+        # First, allow normal attribute access to resolve attributes defined on\n+        # the instance/class (including properties on subclasses). If such an\n+        # attribute exists but raises inside its getter, we should propagate that\n+        # AttributeError rather than masking it with SkyCoord\\'s own message.\n+        try:\n+            return super().__getattribute__(attr)\n+        except AttributeError:\n+            # Only handle SkyCoord-specific dynamic attributes if normal lookup\n+            # failed because the attribute truly does not exist.\n+            pass\n         if \"_sky_coord_frame\" in self.__dict__:\n             if self._is_name(attr):\n                 return self  # Should this be a deepcopy of self?\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14182", "model_patch": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8ef..ea2c411c5 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -57,8 +57,18 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, **kwargs):\n+        \"\"\"\n+        Initialize the RST writer.\n+\n+        Accept arbitrary keyword arguments and pass them through to the\n+        FixedWidth base class. This allows options like `header_rows`\n+        (supported by FixedWidth) to be used with the RST writer.\n+        \"\"\"\n+        # Ensure RST-specific defaults while allowing user overrides via kwargs\n+        kwargs.setdefault(\"delimiter_pad\", None)\n+        kwargs.setdefault(\"bookend\", False)\n+        super().__init__(**kwargs)\n \n     def write(self, lines):\n         lines = super().write(lines)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14309", "model_patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex 4b6150f4a..cc08e67af 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,6 +69,11 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n+    # Guard against empty args: when called without a FITS extension and no fileobj,\n+    # args may be empty (e.g., identify_format(\"write\", Table, \"foo.ecsv\", None, [], {})).\n+    # In that case, this is not FITS.\n+    if not args:\n+        return False\n     return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n \n \n", "model_name_or_path": "gpt5"}
