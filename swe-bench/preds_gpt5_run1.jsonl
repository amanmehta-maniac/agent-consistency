{"instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e2729..76bf115ef 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -212,7 +212,7 @@ def _coord_matrix(model, pos, noutp):\n         for i in range(model.n_inputs):\n             mat[i, i] = 1\n         if pos == 'right':\n-            mat = np.roll(mat, (noutp - model.n_outputs))\n+            mat = np.roll(mat, (noutp - model.n_outputs), axis=0)\n     return mat\n \n \n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13033", "model_patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\nindex c279f35f8..d04573d1a 100644\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -70,15 +70,34 @@ class BaseTimeSeries(QTable):\n \n             if not self._required_columns_relax and len(self.colnames) == 0:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but time series has no columns\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural))\n+                raise ValueError(\n+                    \"{} object is invalid - expected required column{} '{}' \"\n+                    \"at the start, but the time series has no columns\".format(\n+                        self.__class__.__name__, plural, \"', '\".join(required_columns)\n+                    )\n+                )\n \n             elif self.colnames[:len(required_columns)] != required_columns:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but found '{}'\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n+                                # Compute the actual prefix and missing required columns to provide\n+                # a clearer, more informative error message.\n+                actual_prefix = self.colnames[:len(required_columns)]\n+                missing = [col for col in required_columns if col not in self.colnames]\n+                if missing:\n+                    missing_str = \"', '\".join(missing)\n+                    detail = f\"missing required column(s): '{missing_str}'\"\n+                else:\n+                    detail = \"incorrect ordering of required columns\"\n+                raise ValueError(\n+                    \"{} object is invalid - expected required column{} '{}' \"\n+                    \"at the start but found '{}' ({}).\".format(\n+                        self.__class__.__name__,\n+                        plural,\n+                        \"', '\".join(required_columns),\n+                        \"', '\".join(actual_prefix) if actual_prefix else \"no columns\",\n+                        detail\n+                    )\n+                )\n \n             if (self._required_columns_relax\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13236", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127a..9865a9b5b 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1244,6 +1244,8 @@ class Table:\n         if (not isinstance(data, Column) and not data_is_mixin\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n             data = data.view(NdarrayMixin)\n+            import warnings\n+            warnings.warn(\"Structured numpy array will be added as a Column in a future release; please wrap data in Column now to avoid automatic conversion to NdarrayMixin.\", FutureWarning)\n             data_is_mixin = True\n \n         # Get the final column name using precedence.  Some objects may not\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13398", "model_patch": "diff --git a/astropy/coordinates/builtin_frames/__init__.py b/astropy/coordinates/builtin_frames/__init__.py\nindex 6fd688c28..131509874 100644\n--- a/astropy/coordinates/builtin_frames/__init__.py\n+++ b/astropy/coordinates/builtin_frames/__init__.py\n@@ -50,6 +50,7 @@ from . import cirs_observed_transforms\n from . import icrs_observed_transforms\n from . import intermediate_rotation_transforms\n from . import ecliptic_transforms\n+from . import itrs_observed_transforms\n \n # Import this after importing other frames, since this requires various\n # transformtions to set up the LSR frames\ndiff --git a/astropy/coordinates/builtin_frames/itrs_observed_transforms.py b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\nnew file mode 100644\nindex 000000000..ee474244c\n--- /dev/null\n+++ b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\n@@ -0,0 +1,91 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\"\"\"\n+Direct transformations between ITRS and observed frames (AltAz, HADec)\n+that stay entirely within the ITRS, avoiding geocentric vs topocentric\n+aberration pitfalls. ITRS positions are treated as time invariant here.\n+\"\"\"\n+import numpy as np\n+\n+from astropy import units as u\n+from astropy.coordinates.matrix_utilities import rotation_matrix, matrix_transpose\n+from astropy.coordinates.baseframe import frame_transform_graph\n+from astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n+from astropy.coordinates.representation import CartesianRepresentation\n+\n+from .altaz import AltAz\n+from .hadec import HADec\n+from .itrs import ITRS\n+from .utils import PIOVER2\n+\n+\n+def _itrs_to_observed_mat(observed_frame):\n+    \"\"\"\n+    Build a rotation matrix from ITRS to the observed frame (AltAz or HADec)\n+    based on the observer EarthLocation geodetic longitude/latitude.\n+    \"\"\"\n+    # Ensure we have an EarthLocation. AltAz/HADec allow anything that can be transformed to ITRS.\n+    if observed_frame.location is None:\n+        raise ValueError(\"Observed frame requires a 'location' EarthLocation for ITRS<->Observed transforms.\")\n+\n+    lon, lat, _ = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+\n+    if isinstance(observed_frame, AltAz):\n+        # AltAz frame is left handed: flip x-axis\n+        elat = lat.to_value(u.radian)\n+        minus_x = np.eye(3)\n+        minus_x[0, 0] = -1.0\n+        mat = (minus_x\n+               @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian)\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    else:\n+        # HADec frame is left handed: flip y-axis\n+        minus_y = np.eye(3)\n+        minus_y[1, 1] = -1.0\n+        mat = (minus_y\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    return mat\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    \"\"\"\n+    Transform from geocentric ITRS to observed topocentric AltAz/HADec by:\n+    - Subtracting the observer geocentric ITRS position to get topocentric ITRS.\n+    - Rotating into the observed frame using the local rotation matrix.\n+    ITRS positions are treated as time-invariant; we adopt the output frame obstime.\n+    \"\"\"\n+    # Observer geocentric ITRS position\n+    obs_itrs = observed_frame.location.get_itrs().cartesian\n+\n+    # Form the topocentric ITRS position\n+    topocentric_itrs_repr = (itrs_coo.cartesian - obs_itrs)\n+\n+    # Rotate into the observed frame\n+    rep = topocentric_itrs_repr.transform(_itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+    \"\"\"\n+    Transform from observed AltAz/HADec to geocentric ITRS by:\n+    - Rotating observed Cartesian back to topocentric ITRS.\n+    - Adding observer geocentric ITRS position to get geocentric ITRS.\n+    The output ITRS obstime is adopted from itrs_frame; positions treated as time-invariant.\n+    \"\"\"\n+    # Rotate observed Cartesian back to topocentric ITRS\n+    topocentric_itrs_repr = observed_coo.cartesian.transform(\n+        matrix_transpose(_itrs_to_observed_mat(observed_coo))\n+    )\n+\n+    # Add observer geocentric ITRS position to get geocentric ITRS\n+    obs_itrs = observed_coo.location.get_itrs().cartesian\n+    rep = topocentric_itrs_repr + obs_itrs\n+\n+    # Realize in the target ITRS frame\n+    if not isinstance(rep, CartesianRepresentation):\n+        rep = rep.to_cartesian()\n+    return itrs_frame.realize_frame(rep)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13453", "model_patch": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229c..4d781354b 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -347,6 +347,27 @@ class HTML(core.BaseReader):\n         self._check_multidim_table(table)\n \n         cols = list(table.columns.values())\n+        # Prepare formatted string values using BaseData machinery to respect formats/fill_values\n+        from . import core as _core_mod\n+        _data = self.data_class()\n+        # Set header colnames to match current columns for formatting\n+        import types as _types\n+        _data.header = _types.SimpleNamespace(colnames=[col.info.name for col in cols])\n+        _data.cols = cols.copy()\n+        # Propagate formats and fill_values from this reader\n+        _data.formats = dict(getattr(self, 'formats', {}) or {})\n+        # Use the BaseData instance default fill_values (list) if self has no explicit list\n+        _data.fill_values = list(getattr(getattr(self, 'data', _data), 'fill_values', []))\n+        col_str_lists = _data.str_vals()\n+\n+\n+        # Apply user-specified formats to columns so iter_str_vals() respects them\n+        formats = getattr(self, 'formats', {})\n+        if formats:\n+            for col in cols:\n+                name = col.info.name\n+                if name in formats:\n+                    col.info.format = formats[name]\n \n         self.data.header.cols = cols\n \n@@ -413,35 +434,33 @@ class HTML(core.BaseReader):\n                                     w.start('th')\n                                 w.data(col.info.name.strip())\n                                 w.end(indent=False)\n+                        \n                         col_str_iters = []\n                         new_cols_escaped = []\n \n-                        # Make a container to hold any new_col objects created\n-                        # below for multicolumn elements.  This is purely to\n-                        # maintain a reference for these objects during\n-                        # subsequent iteration to format column values.  This\n-                        # requires that the weakref info._parent be maintained.\n+                        # Keep refs for potential multicolumn handling\n                         new_cols = []\n \n-                        for col, col_escaped in zip(cols, cols_escaped):\n+                        for col, col_escaped, col_strs in zip(cols, cols_escaped, col_str_lists):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n                                 for i in range(span):\n-                                    # Split up multicolumns into separate columns\n-                                    new_col = Column([el[i] for el in col])\n-\n-                                    new_col_iter_str_vals = self.fill_values(\n-                                        col, new_col.info.iter_str_vals())\n-                                    col_str_iters.append(new_col_iter_str_vals)\n+                                    # Split up multicolumns into separate columns and format each subcolumn\n+                                    subcol = Column([el[i] for el in col])\n+                                    # Inherit parent formatting if set\n+                                    try:\n+                                        subcol.info.format = col.info.format\n+                                    except Exception:\n+                                        pass\n+                                    sub_iter = self.fill_values(col, subcol.info.iter_str_vals())\n+                                    col_str_iters.append(sub_iter)\n                                     new_cols_escaped.append(col_escaped)\n-                                    new_cols.append(new_col)\n+                                    new_cols.append(subcol)\n                             else:\n-\n-                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n+                                # Use the already-formatted strings from BaseData.str_vals()\n+                                col_iter_str_vals = self.fill_values(col, iter(col_strs))\n                                 col_str_iters.append(col_iter_str_vals)\n-\n                                 new_cols_escaped.append(col_escaped)\n-\n                     for row in zip(*col_str_iters):\n                         with w.tag('tr'):\n                             for el, col_escaped in zip(row, new_cols_escaped):\n@@ -474,4 +493,4 @@ class HTML(core.BaseReader):\n                     yield col.fill_values[col_str]\n                     continue\n \n-            yield col_str\n+            yield col_str\n\\ No newline at end of file\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13579", "model_patch": "diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\nindex d7605b078..50e0b9d2f 100644\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n@@ -246,13 +246,22 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n         world_arrays = tuple(map(np.asanyarray, world_arrays))\n         world_arrays_new = []\n         iworld_curr = -1\n+        # Determine appropriate values for dropped world axes based on the pixel slice\n+        rep_pixel = []\n+        for ipix in range(self._wcs.pixel_n_dim):\n+            sl = self._slices_pixel[ipix]\n+            if isinstance(sl, numbers.Integral):\n+                rep_pixel.append(sl)\n+            else:\n+                start = sl.start if isinstance(sl, slice) else None\n+                rep_pixel.append(0 if start is None else start)\n+        rep_world = self._wcs.pixel_to_world_values(*rep_pixel)\n         for iworld in range(self._wcs.world_n_dim):\n             if iworld in self._world_keep:\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n-                world_arrays_new.append(1.)\n-\n+                world_arrays_new.append(np.asanyarray(rep_world[iworld]))\n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n \n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13977", "model_patch": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb..e9a3b7be5 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -664,10 +664,16 @@ class Quantity(np.ndarray):\n             )\n \n         # Same for inputs, but here also convert if necessary.\n+        # If conversion fails due to incompatible input (e.g., a duck type that\n+        # cannot be coerced), return NotImplemented to allow reflected operations.\n         arrays = []\n-        for input_, converter in zip(inputs, converters):\n-            input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+        try:\n+            for input_, converter in zip(inputs, converters):\n+                input_ = getattr(input_, \"value\", input_)\n+                arrays.append(converter(input_) if converter else input_)\n+        except (ValueError, TypeError):\n+            # Defer to other operand's __array_ufunc__/reflected operation\n+            return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14096", "model_patch": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0..bd701145c 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -894,11 +894,7 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n-        # Fail\n-        raise AttributeError(\n-            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n-        )\n-\n+        return object.__getattribute__(self, attr)\n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\n         if \"_sky_coord_frame\" in self.__dict__:\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14182", "model_patch": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8ef..98c6c4954 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -57,8 +57,17 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, **kwargs):\n+        \"\"\"\n+        Initialize the RST writer.\n+\n+        Accept arbitrary keyword arguments and pass them to the FixedWidth\n+        parent class to enable options like ``header_rows``.\n+        \"\"\"\n+        defaults = dict(delimiter_pad=None, bookend=False)\n+        defaults.update(kwargs)\n+        \n+        super().__init__(**defaults)\n \n     def write(self, lines):\n         lines = super().write(lines)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14309", "model_patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex 4b6150f4a..8f00d0f2a 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,7 +69,7 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n-    return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    return (len(args) > 0) and isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n \n \n def _decode_mixins(tbl):\n", "model_name_or_path": "gpt5"}
