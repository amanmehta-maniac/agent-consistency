{"instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e2729..76bf115ef 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -212,7 +212,7 @@ def _coord_matrix(model, pos, noutp):\n         for i in range(model.n_inputs):\n             mat[i, i] = 1\n         if pos == 'right':\n-            mat = np.roll(mat, (noutp - model.n_outputs))\n+            mat = np.roll(mat, (noutp - model.n_outputs), axis=0)\n     return mat\n \n \n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13033", "model_patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\nindex c279f35f8..dd75ef65b 100644\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -76,9 +76,27 @@ class BaseTimeSeries(QTable):\n \n             elif self.colnames[:len(required_columns)] != required_columns:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but found '{}'\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n+                            # Build a clearer error message that indicates missing or mismatched\n+                            # required columns instead of only reporting the first column.\n+                            present = self.colnames[:len(required_columns)]\n+                            # Identify missing required columns (those in required_columns but not in present)\n+                            missing = [col for col in required_columns if col not in self.colnames]\n+                            if missing:\n+                                raise ValueError(\n+                                    \"{} object is invalid - missing required column{}: {}\"\n+                                    .format(self.__class__.__name__,\n+                                            's' if len(missing) > 1 else '',\n+                                            \"', '\".join(missing))\n+                                )\n+                            else:\n+                                # Columns exist but ordering or leading segment does not match expected\n+                                raise ValueError(\n+                                    \"{} object is invalid - expected leading column{} '{}' but found '{}'\"\n+                                    .format(self.__class__.__name__,\n+                                            plural,\n+                                            \"', '\".join(required_columns),\n+                                            \"', '\".join(present))\n+                                )\n \n             if (self._required_columns_relax\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):\n@@ -89,4 +107,4 @@ class BaseTimeSeries(QTable):\n         self._required_columns_enabled = False\n         yield\n         self._required_columns_enabled = True\n-        self._check_required_columns()\n+        self._check_required_columns()\n\\ No newline at end of file\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13236", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127a..f7ff64419 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1243,6 +1243,7 @@ class Table:\n         # mixin class\n         if (not isinstance(data, Column) and not data_is_mixin\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n+            warnings.warn('Adding a structured numpy array to Table will no longer auto-convert to NdarrayMixin in a future release; please wrap the data in Column now. In 5.2, structured arrays will be added as a Column.', FutureWarning)\n             data = data.view(NdarrayMixin)\n             data_is_mixin = True\n \n@@ -3969,4 +3970,4 @@ class QTable(Table):\n         else:\n             col = super()._convert_col_for_table(col)\n \n-        return col\n+        return col\n\\ No newline at end of file\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13398", "model_patch": "diff --git a/astropy/coordinates/builtin_frames/__init__.py b/astropy/coordinates/builtin_frames/__init__.py\nindex 6fd688c28..17f464246 100644\n--- a/astropy/coordinates/builtin_frames/__init__.py\n+++ b/astropy/coordinates/builtin_frames/__init__.py\n@@ -49,6 +49,7 @@ from . import icrs_cirs_transforms\n from . import cirs_observed_transforms\n from . import icrs_observed_transforms\n from . import intermediate_rotation_transforms\n+from . import itrs_observed_transforms\n from . import ecliptic_transforms\n \n # Import this after importing other frames, since this requires various\ndiff --git a/astropy/coordinates/builtin_frames/itrs_observed_transforms.py b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\nnew file mode 100644\nindex 000000000..4486b7dd5\n--- /dev/null\n+++ b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\n@@ -0,0 +1,91 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\"\"\"\n+Direct transformations between ITRS and observed frames (AltAz, HADec)\n+that stay entirely within ITRS by using topocentric offsets and simple\n+rotation matrices based on the observer's geodetic longitude/latitude.\n+This avoids geocentric vs topocentric aberration issues by treating\n+ITRS positions as time invariant and not performing ITRS->ITRS time\n+referencing.\n+\"\"\"\n+\n+import numpy as np\n+\n+from astropy import units as u\n+from astropy.coordinates.matrix_utilities import rotation_matrix, matrix_transpose\n+from astropy.coordinates.baseframe import frame_transform_graph\n+from astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n+\n+from .altaz import AltAz\n+from .hadec import HADec\n+from .itrs import ITRS\n+from .utils import PIOVER2\n+\n+\n+def _itrs_to_observed_mat(observed_frame):\n+    \"\"\"\n+    Construct the 3x3 rotation matrix that maps ITRS coordinates to\n+    the local observed frame (AltAz or HADec) at the given EarthLocation.\n+    \"\"\"\n+    lon, lat, _ = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+\n+    if isinstance(observed_frame, AltAz):\n+        # AltAz frame: az increasing East of North, altitude up.\n+        # AltAz frame in astropy is left-handed relative to ITRS.\n+        elat = lat.to_value(u.radian)\n+        minus_x = np.eye(3)\n+        minus_x[0, 0] = -1.0\n+        mat = (minus_x\n+               @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian)\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    else:\n+        # HADec frame: hour angle to the west (increases with time), declination.\n+        # HADec frame is left-handed.\n+        minus_y = np.eye(3)\n+        minus_y[1, 1] = -1.0\n+        mat = (minus_y\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    return mat\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    \"\"\"\n+    Transform an ITRS coordinate to an observed frame (AltAz or HADec)\n+    by:\n+      - subtracting the observer geocentric ITRS position to get a\n+        topocentric ITRS vector\n+      - rotating into the observed frame using a simple matrix built\n+        from the observer's geodetic longitude/latitude.\n+\n+    We deliberately do not try to synchronize obstimes between input/output,\n+    and treat ITRS positions as time invariant here to avoid referencing\n+    to the SSB via self-transforms.\n+    \"\"\"\n+    # Form the Topocentric ITRS position\n+    topocentric_itrs_repr = (itrs_coo.cartesian\n+                             - observed_frame.location.get_itrs().cartesian)\n+    rep = topocentric_itrs_repr.transform(_itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+    \"\"\"\n+    Transform an observed coordinate (AltAz or HADec) to ITRS by:\n+      - rotating the observed vector back to topocentric ITRS\n+      - adding the observer geocentric ITRS position to get a geocentric\n+        ITRS position.\n+\n+    The output ITRS frame's obstime is adopted without attempting any\n+    time-referencing of ITRS positions.\n+    \"\"\"\n+    # Topocentric ITRS position from observed via transpose rotation\n+    topocentric_itrs_repr = observed_coo.cartesian.transform(\n+        matrix_transpose(_itrs_to_observed_mat(observed_coo))\n+    )\n+    # Geocentric ITRS position\n+    rep = topocentric_itrs_repr + observed_coo.location.get_itrs().cartesian\n+    return itrs_frame.realize_frame(rep)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13453", "model_patch": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229c..95b2e85d8 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -413,6 +413,33 @@ class HTML(core.BaseReader):\n                                     w.start('th')\n                                 w.data(col.info.name.strip())\n                                 w.end(indent=False)\n+                        # Apply user-specified formats on the source table columns\n+                        try:\n+                            fmts = getattr(self.data, 'formats', {}) or {}\n+                            for _c in cols:\n+                                _name = _c.info.name\n+                                if _name in fmts:\n+                                    _parent = getattr(_c.info, '_parent', None)\n+                                    if _parent is not None and _name in _parent.colnames:\n+                                        _parent[_name].info.format = fmts[_name]\n+                                    else:\n+                                        _c.info.format = fmts[_name]\n+                        except Exception:\n+                            pass\n+                        # Apply user-specified formats to local cols so iter_str_vals respects them\n+                        try:\n+                            fmts = getattr(self.data, 'formats', {}) or {}\n+                            for _c in cols:\n+                                if _c.info.name in fmts:\n+                                    _c.info.format = fmts[_c.info.name]\n+                        except Exception:\n+                            pass\n+                        # Ensure user-supplied formats and fill values are applied\n+                        try:\n+                            self.data._set_fill_values(cols)\n+                            self.data._set_col_formats()\n+                        except Exception:\n+                            pass\n                         col_str_iters = []\n                         new_cols_escaped = []\n \n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13579", "model_patch": "diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\nindex d7605b078..85f030217 100644\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n@@ -246,12 +246,14 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n         world_arrays = tuple(map(np.asanyarray, world_arrays))\n         world_arrays_new = []\n         iworld_curr = -1\n+        # Compute representative world values for dropped axes at the sliced reference pixel\n+        ref_world_coords = self._pixel_to_world_values_all(*[0] * len(self._pixel_keep))\n         for iworld in range(self._wcs.world_n_dim):\n             if iworld in self._world_keep:\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n-                world_arrays_new.append(1.)\n+                world_arrays_new.append(ref_world_coords[iworld])\n \n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-13977", "model_patch": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb..e6d1775b6 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -667,7 +667,13 @@ class Quantity(np.ndarray):\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except (ValueError, TypeError):\n+                # If an input cannot be converted to the expected type/unit,\n+                # return NotImplemented so that NumPy can try reflected or\n+                # other operand implementations instead of raising here.\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14096", "model_patch": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0..f18380f8e 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -2,6 +2,7 @@ import copy\n import operator\n import re\n import warnings\n+import inspect\n \n import erfa\n import numpy as np\n@@ -871,6 +872,10 @@ class SkyCoord(ShapedLikeNDArray):\n         Overrides getattr to return coordinates that this can be transformed\n         to, based on the alias attr in the primary transform graph.\n         \"\"\"\n+        # If attribute exists on the class (e.g., a property in a subclass),\n+        # access it directly so that any inner AttributeError is not masked.\n+        if inspect.getattr_static(type(self), attr, None) is not None:\n+            return object.__getattribute__(self, attr)\n         if \"_sky_coord_frame\" in self.__dict__:\n             if self._is_name(attr):\n                 return self  # Should this be a deepcopy of self?\n@@ -886,8 +891,13 @@ class SkyCoord(ShapedLikeNDArray):\n \n             # Some attributes might not fall in the above category but still\n             # are available through self._sky_coord_frame.\n-            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n-                return getattr(self._sky_coord_frame, attr)\n+            if not attr.startswith(\"_\"):\n+                try:\n+                    value = getattr(self._sky_coord_frame, attr)\n+                except AttributeError:\n+                    pass\n+                else:\n+                    return value\n \n             # Try to interpret as a new frame for transforming.\n             frame_cls = frame_transform_graph.lookup_name(attr)\n@@ -905,7 +915,14 @@ class SkyCoord(ShapedLikeNDArray):\n             if self._is_name(attr):\n                 raise AttributeError(f\"'{attr}' is immutable\")\n \n-            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n+            if not attr.startswith(\"_\"):\n+                try:\n+                    getattr(self._sky_coord_frame, attr)\n+                except AttributeError:\n+                    pass\n+                else:\n+                    setattr(self._sky_coord_frame, attr, val)\n+                    return\n                 setattr(self._sky_coord_frame, attr, val)\n                 return\n \n@@ -932,7 +949,14 @@ class SkyCoord(ShapedLikeNDArray):\n             if self._is_name(attr):\n                 raise AttributeError(f\"'{attr}' is immutable\")\n \n-            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n+            if not attr.startswith(\"_\"):\n+                try:\n+                    getattr(self._sky_coord_frame, attr)\n+                except AttributeError:\n+                    pass\n+                else:\n+                    delattr(self._sky_coord_frame, attr)\n+                    return\n                 delattr(self._sky_coord_frame, attr)\n                 return\n \n@@ -1858,7 +1882,6 @@ class SkyCoord(ShapedLikeNDArray):\n                 return False\n \n         return (x < xmax) & (x > 0) & (y < ymax) & (y > 0)\n-\n     def radial_velocity_correction(\n         self, kind=\"barycentric\", obstime=None, location=None\n     ):\n@@ -2220,4 +2243,4 @@ class SkyCoord(ShapedLikeNDArray):\n         if frame in (\"icrs\", icrs_coord.__class__):\n             return icrs_sky_coord\n         else:\n-            return icrs_sky_coord.transform_to(frame)\n+            return icrs_sky_coord.transform_to(frame)\n\\ No newline at end of file\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14182", "model_patch": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8ef..78e42b7d6 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -57,8 +57,8 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, header_rows=None):\n+        super().__init__(delimiter_pad=None, bookend=False, header_rows=header_rows)\n \n     def write(self, lines):\n         lines = super().write(lines)\n", "model_name_or_path": "gpt5"}
{"instance_id": "astropy__astropy-14309", "model_patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex 4b6150f4a..7cb12237f 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,7 +69,7 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n-    return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    return (len(args) > 0 and isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU)))\n \n \n def _decode_mixins(tbl):\n", "model_name_or_path": "gpt5"}
